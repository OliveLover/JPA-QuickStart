<h1>4. 다대일 연관관계 매핑</h1>

<h3>1. 연관관계 매핑 기준</h3>

|기준|설명|
|:---:|:---:|
|방향성<br />(Direction)|방향성은 단방향 관계와 양방향 관계가 있습니다.<br /> 예를 들어 직원(Employee)객체가 참조 변수를 통해 부서(Department) 객체를 참조하면 단반향입니다.<br />하지만 반대로 부서 객체도 참조 변수를 통해 직원 객체를 참조한다면 양방향이 됩니다. <br />중요한 것은 방향은 객체에만 존재하고 테이블은 항상 양방향이라는 것입니다.|
|다중성<br />(Multiplicity)|다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:N)관계가 있습니다.<br />예를 들어 여러 직원이 하나의 부서에 속해 있다면 직원과 부서의 관계는 다대일 관계입니다.<br />하지만 반대로 부서 입장에서 보면 일대다 관계가 됩니다.<br />그런데 직원이 여러 부서에 소속될 수 있다고 가정하면 다대다 관계로 바뀌게 됩니다.<br />이렇게 다중성은 비즈니스에 따라서 변경될 수 있습니다.|

<h3>2. 다대일 단방향 매핑</h3>

<h4>가정</h4>

```
직원(Employee)과 부서(Dempartment)가 있습니다.
직원 여러 명은 하나의 부서에 소속됩니다.
직원과 부서는 다대일(N : 1) 관계입니다.
직원을 조회했을 때, 직원이 속해 있는 부서 정보도 같이 조회됩니다.
반대로 부서를 통해서 직원 정보에 접근할 수 없습니다.
```
<h4>ERD Diagram</h4>
<img width="604" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/07883519-8dc9-4627-b938-dd0eb613fdcd">

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_DEPT")
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long deptId;

    @Column(length = 25, nullable = false)
    private String name;
}
```

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @ManyToOne
    @JoinColumn(name = "DEPT_ID")
    private Department dept;
}
```

<p><code>부서 테이블(S_DEPT)</code>과 매핑되는 <code>부서 객체</code>는 <code>직원(Employee) 객체</code>로 부터 참조 당하는 입장이기 때문에 연관관계 매핑과 관련해서 특별히 추가할 설정은 없습니다. </p>

<p><code>직원(Employee)</code> 클래스에서 가장 중요한 것은 <code>부서(Department)</code> 엔티티를 참조하는 <code>dept</code> 참조 변수 입니다. <code>@ManyToOne</code>은 <code>다(Many)</code>에 해당하는 엔티티가 <code>일(One)</code>에 해당하는 엔티티를 참조할 때 <code>다(Many)</code>에 해당하는 엔티티에 설정해야 합니다. </p>

<p><code>@JoinColumn</code>은 조인에 사용할 외래 키 칼럼을 매핑할 때 사용합니다. 위 설정대로라면 현재 <code>Employee</code>엔티티와 매핑된 <code>S_EMP</code>테이블에 <code>DEPT_ID</code> 칼럼을 외래 키로 설정한다는 의미입니다.</p>

<h4>@JoinColumn 생략 시 JPA 자동 네이밍 규칙</h4>

```
참조변수 이름 + '_' + 참조하는 테이블의 주 키 칼럼 이름
```

```
Hibernate:
  create table S_EMP (
    id bigint generated by default as identity,
    name varchar(25) not null,
    dept_DEPT_ID bigint,
    primary key (id)
  )
```

<h4>@ManyToOne 어노테이션이 지원하는 속성</h4>

|속성|기능|기본 값|
|:---:|:---|:---|
|optional|연관된 엔티티가 반드시 있어야 하는지 여부를 결정<br />false로 설정하면 항상 있어야 한다는 의미|true|
|fetch|글로벌 패치 전략을 설정<br />EAGER는 연관 엔티티를 동시에 조회하며, LAZY는 연관 엔티티를 실제 사용할 때 조회|@MantyToOne:EAGER<br />@OneToMany:LAZY|
|cascade|영속성 전이 기능을 설정<br />연관 엔티티를 같이 저장하거나 삭제할 때 사용||

<h3>3. 연관관계를 이용한 데이터 등록</h3>

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class ManyToOneOneWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
        em.persist(department);

        // 직원 등록
        Employee employee1 = new Employee();
        employee1.setName("개발부");
        employee1.setDept(department);
        em.persist(employee1);

        // 직원 등록
        Employee employee2 = new Employee();
        employee2.setName("도우너");
        employee2.setDept(department);
        em.persist(employee2);

        em.getTransaction().commit();
        em.close();
    }
}
```

<img width="176" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/a8eda718-f420-4256-87d0-7db17e9deee6">

<p>엔티티 클래스에 설정된 연관관계 매핑을 기반으로 실질적인 <code>SQL</code>을 생성하는 것은 <code>영속 컨테이너</code>입니다. <code>영속 컨테이너</code>는 관리 상태의 엔티티만 인지할 수 있기 때문에 당연히 연관관계에 참여하는 모든 엔티티는 관리 상태로 존재해야 합니다. 따라서 클라이언트는<code>직원(Employee)</code> 엔티티를 <code>등록(persist)</code>하기 전에 <code>부서(Depratment)</code> 엔티티를 먼저 관리 상태로 만든 것입니다. 그래야 <code>영속 컨테이너</code>가 직원 객체를 <code>관리 상태</code>로 만들 때 <code>부서 엔티티</code>를 이용할 수 있으며, 이런 관계를 바탕으로 <code>컨테이너</code>가 생성하는 <code>INSERT</code>구문에 <code>외래 키</code> 정보도 설정할 수 있는 것입니다.</p>

<p> <code>@JoinColumn</code> 설정으로 인해 <code>S_EMP</code>테이블에 <code>DEPT_ID</code> 칼럼이 추가되었다는 것과 <code>Employee</code>가 참조하는 <code>Department</code>객체의 식별자 값이 저장되었다는 것입니다. 결국 <cocde>@JoinColumn(name = "DEPT_ID")</cocde>는 <code>dept</code> 변수가 참조하는 <code>Department</code>객체의 식별자 값을 <code>외래 키</code>에 해당하는 <code>DEPT_ID</code>칼럼에 저장하라는 의미입니다.</p>

<h3>4. 연관관계를 이용한 데이터 검색</h3>

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class ManyToOneOneWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        Employee employee = em.find(Employee.class, 2L);
        System.out.println(employee.getName() + "의 부서 : " + employee.getDept().getName());
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
        em.persist(department);

        // 직원 등록
        Employee employee1 = new Employee();
        employee1.setName("개발부");
        employee1.setDept(department);
        em.persist(employee1);

        // 직원 등록
        Employee employee2 = new Employee();
        employee2.setName("도우너");
        employee2.setDept(department);
        em.persist(employee2);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate:
    select
        employee0_.id as id1_1_0_,
        employee0_.DEPT_ID as DEPT_ID3_1_0_,
        employee0_.name as name2_1_0_,
        department1_.DEPT_ID as DEPT_ID1_0_1_,
        department1_.name as name2_0_1_
    from
        S_EMP employee0_
    left outer join
        S_DEPT department1_
                on employee0_.DEPT_ID=department1_.DEPT_ID
    where
        employee_.id=?

도우너의 부서 : 개발부
```

<p>실행 결과를 보면 <code>EntityManager</code>의 <code>find</code>메소드가 호출될 때 <code>S_EMP</code> 테이블과 <code>S_DEPT</code>테이블이 조인으로 연결되는 것을 확인할 수 있습니다. 또한, <code>JDBC</code>의 복잡한 연관관계 매핑 코드들을 많이 줄일 수 있습니다.</p>

<h3>5. 외부 조인을 내부 조인으로 변경하기</h3>

<p><code>@ManyToOne</code>을 사용하여 연관관계를 매핑하면 <code>영속 컨테이너</code>는 기본적으로 <code>외부 조인(OUTER JOIN)</code>에 해당하는 쿼리를 생성합니다. 일반적으로 <code>외부 조인</code>은 조인 조건을 충족하지 못하는 데이터까지 조회 결과에 포함시킬 때 사용합니다. 따라서 조인 조건을 만족하는 데이터만 조회하는 경우에는 성능이 느린 <code>외부 조인(OUTER JOIN)</code>보다는 <code>내부 조인(INNER JOIN)</code>을 이용하는 것이 낫습니다.</p>
<p><code>@ManyToOne</code>을 이용한 다대일 매핑에서 <code>외부 조인</code>을 <code>내부 조인</code>으로 변경하기 위해서는 <code>optional</code> 속성을 이용하면 됩니다. <code>@ManyToOne</code>어노테이션에 <code>optional="true"</code>를 추가하면 <code>Employee.dept</code> 변수와 매핑되는 <code>DEPT_ID</code>칼럼도 반드시 <code>외래 키</code>에 해당하는 값이 저장되어야 합니다. 이 설정에 의해 <code>영속 컨테이너</code>는 <code>외부 조인</code>을 내부 조인으로 변경하여 쿼리를 제너레이션하는 것입니다.</p>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @ManyToOne(optional = false)
    @JoinColumn(name = "DEPT_ID")
    private Department dept;
}
```

```
Hibernate:
    select
        employee0_.id as id1_1_0_,
        employee0_.DEPT_ID as DEPT_ID3_1_0_,
        employee0_.name as name2_1_0_,
        department1_.DEPT_ID as DEPT_ID1_0_1_,
        department1_.name as name2_0_1_
    from
        S_EMP employee0_
    innerjoin
        S_DEPT department1_
            on employee0_DEPT_ID=department1_.DEPT_ID
    where
        employee0_.id=?
```

<h3>6. 페치 설정 변경하기</h3>

<p><code>@ManyToOne</code>은 <code>다(Many)</code>에 해당하는 직원 정보를 조회 했을 때, <code>일(One)</code>에 해당하는 부서 정보까지 같이 가져오기 위해서 조인 쿼리를 실행합니다.</p>
<p>하지만, 비즈니스 특성상 검색 결과에서 직원 정보만 사용하고 부서 정보는 사용하지 않는다면, 처음부터 사용하지 않을 부서 정보까지 모두 가져오는 것은 비효율적입니다. 이런 문제를 해결하기 위해서 <code>JPA</code>에서는 <code>fetch</code>속성을 지원합니다. <code>fetch</code>속성을 이용하면 연관관계에 있는 객체를 가져오는 시점을 결정할 수 있습니다.</p>

<h4>fetch 속성 값</h4>
<ul>
    <li><code>FetchType.EAGER</code> : 데이터를 조회할 때 연관된 데이터까지 같이 가져온다는 의미(default)</li>
    <li><code>FetchType.LAZY</code> : 실제 객체가 사용되는 시점까지 가져오는 시점을 지연시키라는 의미</li>
</ul>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @ManyToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "DEPT_ID")
    private Department dept;
}
```

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class ManyToOneOneWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        Employee employee = em.find(Employee.class, 2L);
        System.out.println(employee.getName() + " 직원이 검색됨");
//        System.out.println(employee.getName() + " 의 부서 : " +
                employee.getDept().getName());
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
        em.persist(department);

        // 직원 등록
        Employee employee1 = new Employee();
        employee1.setName("개발부");
        employee1.setDept(department);
        em.persist(employee1);

        // 직원 등록
        Employee employee2 = new Employee();
        employee2.setName("도우너");
        employee2.setDept(department);
        em.persist(employee2);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate:
    select
        employee0_.id as id_1_0_,
        employee0_.DETP_ID as DEPT_ID3_1_0_,
        employee0_.name as name2_1_0_
    from
        S_EMP employee0_
    where
        employee0_.id=?
```

<p>실행 결과를 보면 페치 설정을 <code>FetchType.LAZY</code>로 설정하면 <code>Employee</code>를 검색할 때, 내부적으로 조인을 사용하지 않습니다. <code>S_DEPT</code>테이블에 대한 검색도 일어나지 않았는데, 이는 클라이언트에서 부서 관련 데이터를 사용하지 않았기 때문입니다.</p>

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class ManyToOneOneWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
            dataUpdate(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataUpdate(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 신규 부서 등록
        Department department = new Department();
        department.setName("영업부");
        em.persist(department);

        // 부서 변경
        Employee employee = em.find(Employee.class, 1L);
        employee.setDept(department);
        em.getTransaction().commit();
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        Employee employee = em.find(Employee.class, 2L);
//        System.out.println(employee.getName() + " 직원이 검색됨");
        System.out.println(employee.getName() + " 의 부서 : " +
                employee.getDept().getName());
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
        em.persist(department);

        // 직원 등록
        Employee employee1 = new Employee();
        employee1.setName("개발부");
        employee1.setDept(department);
        em.persist(employee1);

        // 직원 등록
        Employee employee2 = new Employee();
        employee2.setName("도우너");
        employee2.setDept(department);
        em.persist(employee2);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate:
    select
        employee0_.id as id1_1_0_,
        employee0_.DEPT_ID as DEPT_ID3_1_0_,
        employee0_.name as name2_1_0_
    from
        S_EMP employee0_
    where
        employee0_.id=?

Hibernate:
    select
        department0_.DEPT_ID as DEPT_ID1_0_0_,
        department0_.name as name2_0_0_
    from
        S_DEPT department0_
    where
        department0_.DEPT_ID=?

도우너 부서 : 개발부
```

<p><code>fetch</code> 속성을 <code>FetchType.LAZY</code>로 설정하면 연관 객체에 대한 <code>SELECT</code>를 실제 해당 객체가 사용되는 시점으로 미루기 때문에 검색과 관련해서 애플리케이션의 성능을 향상할 수 있습니다.</p>

<p>사실 <code>@ManyToOne</code>이나 <code>@OneToMany</code>를 설정할 때 연관데이터를 <code>즉시(EAGER)</code> 읽어올지, <code>지연(Lazy)</code>해서 읽어올지는 비즈니스의 상황에 따라 달라지기 때문에 페치 유형을 미리 결정하는 것은 비효율적입니다. 따라서 <code>페치 전략</code>은 기본적으로 <code>LAZY</code>로 설정해놓고 비즈니스의 특성에 따라서 <code>EAGER</code>로 변경하는 것이 좋습니다.</p>

<p>참고로 <code>@ManyToOne</code>은 <code>일(One)</code>에 해당하는 객체가 하나밖에 없으므로 <code>다(Many)</code>에 해당하는 객체를 조회했을 때, 일에 해당하는 객체를 조인을 통해 <code>즉시(EAGER)</code> 가져오는 것이 효율적일 수 있습니다. 그래서 <code>@ManyToOne</code>의 <code>fetch</code>속성은 기본값이 <code>FetchType.EAGER</code>로 되어있습니다.</p>

<p>하지만 일대다 관계를 매핑할 때 사용하는 <code>@OneToMany</code>는 <code>다(Many)</code>에 해당하는 객체가 컬렉션 형태로 여러 개 존재합니다. 따라서 연관 객체가 사용되는 시점에 <code>SELECT</code>를 처리하는 <code>FetchType.LAZY</code>가 기본 설정인 것입니다.</p>

<h3>7. 연관관계 수정</h3>

<p><code>dataUpdate</code>메소드를 추가합니다.</p>

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class ManyToOneOneWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
            dataUpdate(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataUpdate(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 신규 부서 등록
        Department department = new Department();
        department.setName("영업부");
        em.persist(department);

        // 부서 변경
        Employee employee = em.find(Employee.class, 1L);
        employee.setDept(department);
        em.getTransaction().commit();
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        Employee employee = em.find(Employee.class, 2L);
//        System.out.println(employee.getName() + " 직원이 검색됨");
        System.out.println(employee.getName() + " 의 부서 : " +
                employee.getDept().getName());
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
        em.persist(department);

        // 직원 등록
        Employee employee1 = new Employee();
        employee1.setName("개발부");
        employee1.setDept(department);
        em.persist(employee1);

        // 직원 등록
        Employee employee2 = new Employee();
        employee2.setName("도우너");
        employee2.setDept(department);
        em.persist(employee2);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate:
    select
        employee0_.id as id1_1_0_,
        employee0_.DEPT_ID as DEPT_ID3_1_0_,
        employee0_.name as name2_1_0_
    from
        S_EMP employee0_
    where
        employee0_.id=?

Hibernate:
    update
        S_EMP
    set
        DEPT_ID=?,
        name=?
    where
        id=?
```

<img width="164" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/91dd0d51-7e8c-45e2-ab5c-3b25f130af42">

<h3>8. 연관 엔티티 삭제</h3>

<p><code>JPA</code>에서 특정 데이터를 삭제 하고 싶은 경우, 먼저 삭제할 데이터에 대한 엔티티를 검색하고 검색된 엔티티를 <code>remove</code>메소드를 이용하여 삭제 상태로 만듭니다. 하지만 연관관계에 있는 엔티티를 삭제할 때는 주의가 필요합니다. 연관관계가 있는 엔티티들을 먼저 삭제하거나 연관관계를 모두 제거해야 할 필요가 있습니다. 그렇지 않으면 <code>외래 키</code>제약조건에 의해문제가 발생하기 때문입니다.</p>

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class ManyToOneOneWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
            dataDelete(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataDelete(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서에 대한 참조 제거
        Employee employee1 = em.find(Employee.class, 1L);
        employee1.setDept(null);
        Employee employee2 = em.find(Employee.class, 2L);
        employee2.setDept(null);

        Department department = em.find(Department.class, 1L);
        em.remove(department);
        em.getTransaction().commit();
    }

    private static void dataUpdate(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 신규 부서 등록
        Department department = new Department();
        department.setName("영업부");
        em.persist(department);

        // 부서 변경
        Employee employee = em.find(Employee.class, 1L);
        employee.setDept(department);
        em.getTransaction().commit();
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        Employee employee = em.find(Employee.class, 2L);
//        System.out.println(employee.getName() + " 직원이 검색됨");
        System.out.println(employee.getName() + " 의 부서 : " +
                employee.getDept().getName());
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
        em.persist(department);

        // 직원 등록
        Employee employee1 = new Employee();
        employee1.setName("개발부");
        employee1.setDept(department);
        em.persist(employee1);

        // 직원 등록
        Employee employee2 = new Employee();
        employee2.setName("도우너");
        employee2.setDept(department);
        em.persist(employee2);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate: 
    update
        S_EMP 
    set
        DEPT_ID=?,
        name=? 
    where
        id=?
Hibernate: 
    update
        S_EMP 
    set
        DEPT_ID=?,
        name=? 
    where
        id=?
Hibernate: 
    delete 
    from
        S_DEPT 
    where
        DEPT_ID=?
```

<p>실행 결과에서 두 직원의부서 정보가 <code>null</code>로 수정되는 두 번의 <code>UPDATE</code>가 먼저 처리됐고, 그리고 나서 부서 데이터를 삭제하는 <code>DELETE</code>실행되는 것을 확인할 수 있습니다. 하지만 대부분의 비즈니스 로직에서는 특정 엔티티를 삭제할 때 연관된 엔티티들의 관계만 제거하는 것이 아니라 연관된 데이터 자체를 삭제합니다.</p>

<h3>9. 다대일 양방향 매핑</h3>

<p>테이블의 양방향과 객체의 양방향 메커니즘은 완전히 다릅니다.</p>

<p>양방향으로 매핑하기 위해서는 다음과 같이 매핑에 참여하는 두 객체 상호간에 참조 변수를 가지도록 해야합니다.</p>

|Employe.java|Department.java|
|:---|:---|
|@Entity<br/>public class Employee {<br /><br />&nbsp;&nbsp;@Id<br />&nbsp;&nbsp;private Long id;<br /><br />&nbsp;&nbsp;<code>private Department dept;</code><br/>}|@Entity<br />public class Department {<br /><br />&nbsp;&nbsp;@Id<br />&nbsp;&nbsp;private Long deptId;<br /><br />&nbsp;&nbsp;<code>private Emloyee emp;</code><br />}|

<p>데이터 모델링 관점에서 테이블을 양방향으로 연결하기 위한 연결점은 하나(외래 키)인데, 객체 지향에서 객첼르 양방향으로 연결하기 위한 연결점은 두 개(객체 참조 변수)입니다. 이 둘을 어떻게 매핑하느냐가 양방향 매핑의 핵심입니다.</p>

```
import lombok.Data;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Data
@Entity
@Table(name = "S_DEPT")
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "DEPT_ID")
    private Long deptId;

    @Column(length = 25, nullable = false)
    private String name;

    @OneToMany(mappedBy = "dept", fetch = FetchType.LAZY)
    private List<Employee> employeeList = new ArrayList<>();
}
```

<p><code>JPA</code>에서는 <code>java.util.List</code>나 <code>java.util.Set</code>같은 컬렉션을 이용하여 <code>일대다(1:M)</code> 관계를 매핑합니다. 위 소스에서는 하나의 부서 엔티티가 여러 개의 직원 객체를 가질 수 있도록 <code>java.util.List</code>타입의 <code>employeeList</code> 변수를 추가했고, 변수 위에 일대다 매핑을 의미하는 <code>@OneToMany</code> 어노테이션을 설정했습니다.</p>

<p>다대일 연관관계 매핑에서 <code>@ManyToOne</code>을 사용했다면 일대다 매핑에서는 컬렉션 변수 위에 <code>@OneToMany</code> 어노테이션을 사용합니다.</p>
<p><code>>mappedBy</code>는 객체를 양방향으로 매핑할 때 연관관계의 <code>소유자(Owner)</code>와 관련된 속성입니다. <code>mappedBy</code>는 <code>연관관계의 소유자가 아닌 객체에 설정하는 속성</code>입니다.</p>

<h3>10. 양방향 연관관계 매핑 검색</h3>

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class ManyToOneBothWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        Department department = em.find(Department.class, 1L);

        System.out.println("검색된 부서 : " + department.getName());
        System.out.println("부서에 소속된 직원 명단");
        for (Employee employee : department.getEmployeeList()) {
            System.out.println(employee.getName() + "(" +
                    employee.getDept().getName() + ")");
        }
    }

    // ManyToOneOneWayClient의 dataInsert 메소드와 동일하다.
    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
        em.persist(department);

        // 직원 등록
        Employee employee1 = new Employee();
        employee1.setName("개발부");
        employee1.setDept(department);
        em.persist(employee1);

        // 직원 등록
        Employee employee2 = new Employee();
        employee2.setName("도우너");
        employee2.setDept(department);
        em.persist(employee2);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate: 
    select
        department0_.DEPT_ID as dept_id1_0_0_,
        department0_.name as name2_0_0_ 
    from
        S_DEPT department0_ 
    where
        department0_.DEPT_ID=?
검색된 부서 : 개발부
부서에 소속된 직원 명단
Hibernate: 
    select
        employeeli0_.DEPT_ID as dept_id3_1_0_,
        employeeli0_.id as id1_1_0_,
        employeeli0_.id as id1_1_1_,
        employeeli0_.DEPT_ID as dept_id3_1_1_,
        employeeli0_.name as name2_1_1_ 
    from
        S_EMP employeeli0_ 
    where
        employeeli0_.DEPT_ID=?
개발부(개발부)
도우너(개발부)
```

<h3>11. 일대다 연관관계 매핑과 컬렉션</h3>

<p>일대다 관계를 매핑할 때는 <code>List</code>나 <code>Set</code> 같은 컬렉션을 사용합니다. 이 두 컬렉션은 동작 메커니즘이 조금 다릅니다. </p>

<p>일대다 연관관계 매핑에서 가장 많이 사용하는 <code>List</code>는 순서대로 객체를 저장하며, 인덱스가 증가합니다. 그리고 동일한 객체에 대한 중복 저장을 허용하는 반면, <code>Set</code>은 객체의 순서를 관리하지 않으며, 객체의 중복 저장도 허용하지 않습니다.</p>

<p><code>Set</code> 컬렉션의 이런 특징들이 정확하게 동작하기 위해서는 반드시 <code>Set</code>에 저장되는 엔티티가 <code>equals</code>와 <code>hashCode</code>메소드를 재정의해야 합니다.</p>

```
import lombok.Data;
import lombok.EqualsAndHashCode;

import javax.persistence.*;
import java.util.HashSet;
import java.util.Set;

@Data
@Entity
@Table(name = "S_DEPT")
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "DEPT_ID")
    private Long deptId;

    @Column(length = 25, nullable = false)
    private String name;

    @OneToMany(mappedBy = "dept")
    private Set<Employee> employeeList = new HashSet<>();
}
```

<p>현재 상태에서 <code>클라이언트(ManyToOneBothWayClient)</code>를 다시 실행하면 예외가 발생합니다. 이는 양방향 참조에서 롬복이 생성한 <code>equals</code>와 <code>hashCode</code>메소드가 순환참조를 하기 때문입니다.</p>
<p>순환참조를 끊기 위해서는 롬복의 <code>@EqualsAndHashCode</code> 어노테이션에서 순환참조에 해당하는 변수를 <code>equals</code>와 <code>hashCode</code>메소드에서 제외시켜야 합니다.</p>

```
package org.example.chapter04.domain;

import lombok.Data;
import lombok.EqualsAndHashCode;

import javax.persistence.*;
import java.util.HashSet;
import java.util.Set;

@Data
@EqualsAndHashCode(exclude = "employeeList")
@Entity
@Table(name = "S_DEPT")
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "DEPT_ID")
    private Long deptId;

    @Column(length = 25, nullable = false)
    private String name;

    @OneToMany(mappedBy = "dept")
    private Set<Employee> employeeList = new HashSet<>();
}
```

<h3>12. 연관관계 소유자</h3>

<p><code>연관관계의 소유자(Owner)</code>는 관계형 데이터베이스와 객체지향의 구조적 불일치 문제를 해결하기 위해 만들어진 개념입니다.</p>
<p>양방향 관계에서 <code>외래 키</code>와 매핑된 참조 변수를 <code>연관관계 소유자(Owner)</code>라고 합니다. 양방향에서는 <code>연관관계 소유자</code>만이 <code>외래 키</code>에 대해 <code>관리(등록, 수정, 삭제)</code>할 수 있고, 반대쪽은 오로지 <code>읽기(조회)</code>만 가능합니다.</p>

|file|code|
|---|---|
|Employee.java|@Data<br />@Entity<br />@Table(name = "S_EMP")<br />public class Employee {<br /><br />&nbsp;&nbsp;@Id<br />&nbsp;&nbsp;@GeneratedValue(strategy = GenerationType.IDENTITY)<br />&nbsp;&nbsp;private Long id;<br /><br />&nbsp;&nbsp;@Column(length = 25, nullable = false)<br />&nbsp;&nbsp;private String name;<br /><br />&nbsp;&nbsp;<code>@ManyToOne(fetch - FetchType.LAZY)</code><br />&nbsp;&nbsp;<code>@JoinColumn(name = "DEPT_ID")</code><br />&nbsp;&nbsp;<code>private Department dept;</code><br />}|
|Department.java|@Data<br />@EqualsAndHashCode(exclude = "employeeList")<br />@Entity<br />@Table(name = "S_DEPT")<br />public class Department {<br /><br />&nbsp;&nbsp;@Id<br />&nbsp;&nbsp;@GeneratedValue(strategy = GenerationType.IDENTITY)<br />&nbsp;&nbsp;@Column(name = "DEPT_ID")<br />&nbsp;&nbsp;private Long deptId;<br /><br />&nbsp;&nbsp;@Column(length = 25, nullable = false)<br />&nbsp;&nbsp;private String name;<br /><br />&nbsp;&nbsp;<code>@OneToMany(mappedBy = "dept")</code><br />&nbsp;&nbsp;<code>private Set\<Employee\> employeeList = new HashSet<Employee>();</code><br />}|

<p>양방향 연관관계에서는 일반적으로 <code>외래 키</code>를 가진 테이블 쪽 엔티티가 연관관계의 소유자가 됩니다. 따러서 <code>S_EMP</code>테이블과 매핑되는 <code>Employee</code>클래스를 소유자로 결정하 것입니다. 소유자인 <code>Employee</code> 클래스에는 소유자와 관련된 어떤 설정도 추가되지 않았고 오히려 반대쪽인 <code>Department.employeeList</code> 변수에 소유자와 관련된 <code>mappedBy</code>설정이 추가됐습니다.</p>
<p><code>mappedBy</code>속성을 사용하여 <code>자신(Department)</code>은 소유자가 아님을 <code>영속 컨테이너</code>에게 알려줍니다.</p>

<h3>13. 양방향 연관관계 매핑을 이용한 등록 처리</h3>

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class ManyToOneBothWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        Department department = em.find(Department.class, 1L);

        System.out.println("검색된 부서 : " + department.getName());
        System.out.println("부서에 소속된 직원 명단");
        for (Employee employee : department.getEmployeeList()) {
            System.out.println(employee.getName() + "(" +
                    employee.getDept().getName() + ")");
        }
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
        em.persist(department);

        // 직원1 등록(Employee --> Department 참조)
        Employee employee1 = new Employee();
        employee1.setName("둘리");
        employee1.setDept(department);
        em.persist(employee1);

        // 직원2 등록(Employee --> Department 참조)
        Employee employee2 = new Employee();
        employee2.setName("도우너");
        employee2.setDept(department);
        em.persist(employee2);

        em.getTransaction().commit();
        em.close();
    }
}
```

<img width="159" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/0cd4cc2a-d3e2-4e14-8ae7-36568dbe6908">

<h3>14. 객체 상태에서의 양방향 설정</h3>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "DEPT_ID")
    private Department dept;

    public void setDept(Department department) {
        this.dept = department;
        // Department 엔티티의 컬렉션에도 Employee 참조를 설정한다.
        department.getEmployeeList().add(this);
    }
}
```

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class ManyToOneBothWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        Department department = em.find(Department.class, 1L);

        System.out.println("검색된 부서 : " + department.getName());
        System.out.println("부서에 소속된 직원 명단");
        for (Employee employee : department.getEmployeeList()) {
            System.out.println(employee.getName() + "(" +
                    employee.getDept().getName() + ")");
        }
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
        em.persist(department);

        // 직원1 등록(Employee --> Department 참조)
        Employee employee1 = new Employee();
        employee1.setName("둘리");
        employee1.setDept(department);
        em.persist(employee1);

        // 직원2 등록(Employee --> Department 참조)
        Employee employee2 = new Employee();
        employee2.setName("도우너");
        employee2.setDept(department);
        em.persist(employee2);

        // Department.employeeList에 Employee 등록
//        department.getEmployeeList().add(employee1);
//        department.getEmployeeList().add(employee2);

        System.out.println(department.getName() + "의 직원 수 : " +
                department.getEmployeeList().size());

        em.getTransaction().commit();
        em.close();
    }
}
```

<h3>15. 영속성 전이</h3>

<p><code>OneToMany</code>나 <code>@OneToOne</code>어노테이션에서는 <code>cascade</code>속성을 사용해서 연관 객체에 대한 <code>영속성 전이(cascade)</code>를 설정할 수 있습니다. <code>cascade</code> 속성 값은 <code>CascadeType</code>에서 제공하는 <code>영속성 전이 유형</code>을 지정할 수 있습니다.</p>

<h4>CascadeType</h4>
<ul>
    <li>PERSIST</li>
    <li>MERGE</li>
    <li>REMOVE</li>
    <li>REFRESH</li>
    <li>DETATCH</li>
    <li>ALL(다섯 가지를 모두 포함)</li>
</ul>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @ManyToOne(cascade = CascadeType.PERSIST)
    @JoinColumn(name = "DEPT_ID")
    private Department dept;

    public void setDept(Department department) {
        this.dept = department;
        // Department 엔티티의 컬렉션에도 Employee 참조를 설정한다.
        department.getEmployeeList().add(this);
    }
}
```

```
package org.example.chapter04.domain;

import lombok.Data;
import lombok.EqualsAndHashCode;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Data
@EqualsAndHashCode(exclude = "employeeList")
@Entity
@Table(name = "S_DEPT")
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "DEPT_ID")
    private Long deptId;

    @Column(length = 25, nullable = false)
    private String name;

    @OneToMany(mappedBy = "dept", cascade = CascadeType.PERSIST)
    private List<Employee> employeeList = new ArrayList<>();
}
```

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class ManyToOneBothWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        Department department = em.find(Department.class, 1L);

        System.out.println("검색된 부서 : " + department.getName());
        System.out.println("부서에 소속된 직원 명단");
        for (Employee employee : department.getEmployeeList()) {
            System.out.println(employee.getName() + "(" +
                    employee.getDept().getName() + ")");
        }
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
//        em.persist(department);

        // 직원 여러 명 등록
        for (int i = 1; i <= 5; i++) {
            Employee employee = new Employee();
            employee.setName("직원-" + i);
            employee.setDept(department);
//            em.persist(employee);
        }
        em.persist(department);

        em.getTransaction().commit();
        em.close();
    }
}
```

<p><code>for</code>문 안의 <code>persist</code>는 사용되지 않고, 마지막에 한 번 <code>Department</code>객체만 <code>persist</code>를 통해 관리 상태로 만들었습니다. 그러면 <code>영속성 전이</code>설정에 의해 <code>Department</code>엔티티가 등록되는 순간 연관관계에 있는 <code>Employee</code>객체도 자동으로 같이 등록됩니다.</p>

<h3>16. 영속성 전이를 이용한 삭제</h3>

```
import lombok.Data;
import lombok.EqualsAndHashCode;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Data
@EqualsAndHashCode(exclude = "employeeList")
@Entity
@Table(name = "S_DEPT")
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "DEPT_ID")
    private Long deptId;

    @Column(length = 25, nullable = false)
    private String name;

    @OneToMany(mappedBy = "dept", cascade = {CascadeType.PERSIST, CascadeType.REMOVE})
    private List<Employee> employeeList = new ArrayList<>();
}
```

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.util.List;

public class ManyToOneBothWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
            dataDelete(emf);
//            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        Department department = em.find(Department.class, 1L);

        System.out.println("검색된 부서 : " + department.getName());
        System.out.println("부서에 소속된 직원 명단");
        for (Employee employee : department.getEmployeeList()) {
            System.out.println(employee.getName() + "(" +
                    employee.getDept().getName() + ")");
        }
    }

    private static void dataDelete(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 검색
        Department department = em.find(Department.class, 1L);

        // 부서에 등록된 직원 삭제
//        List<Employee> employeeList = department.getEmployeeList();
//        for (Employee employee : employeeList) {
//            em.remove(employee);
//        }

        // 부서 삭제
        em.remove(department);

        em.getTransaction().commit();
        em.close();
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
//        em.persist(department);

        // 직원 여러 명 등록
        for (int i = 1; i <= 5; i++) {
            Employee employee = new Employee();
            employee.setName("직원-" + i);
            employee.setDept(department);
//            em.persist(employee);
        }
        em.persist(department);

        em.getTransaction().commit();
        em.close();
    }
}
```

<p>부서만 삭제해도 <code>영속성 전이</code>설정에 의해 부서에 속한 직원도 같이 삭제 됩니다.</p>

<h3>17. 고아제거 속성 사용하기</h3>

<p>부모를 잃고 홀로된 객체를 고아라고 볼 수 있습니다. 부모 엔티티(부서)를 삭제할 때, 연관된 자식 엔티티(직원)가 부모를 잃은 고아가 되는 것입니다. 즉, 고아 객체 제거는 부모와의 연관관계에서 제외된 객체를 자동으로 삭제하는 기능을 의미합니다.</p>

```
import lombok.Data;
import lombok.EqualsAndHashCode;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Data
@EqualsAndHashCode(exclude = "employeeList")
@Entity
@Table(name = "S_DEPT")
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "DEPT_ID")
    private Long deptId;

    @Column(length = 25, nullable = false)
    private String name;

    @OneToMany(mappedBy = "dept", cascade = {CascadeType.PERSIST}, orphanRemoval = true)
    private List<Employee> employeeList = new ArrayList<>();
}
```

<h3>18. null을 이용한 관계 끊기</h3>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @ManyToOne(cascade = CascadeType.PERSIST)
    @JoinColumn(name = "DEPT_ID")
    private Department dept;

    public void setDept(Department department) {
        this.dept = department;
        // Department 엔티티의 컬렉션에도 Employee 참조를 설정한다.
        department.getEmployeeList().add(this);
    }

    // 부서 정보를 null로 설정하여 직원을 대기 상태로 전환시킨다.
    public void standby() {
        this.dept = null;
    }
}
```

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @ManyToOne(cascade = CascadeType.PERSIST)
    @JoinColumn(name = "DEPT_ID")
    private Department dept;

    public void setDept(Department department) {
        this.dept = department;
        // Department 엔티티의 컬렉션에도 Employee 참조를 설정한다.
        department.getEmployeeList().add(this);
    }

    // 부서 정보를 null로 설정하여 직원을 대기 상태로 전환시킨다.
    public void standby() {
        this.dept = null;
    }
}
```

```
import lombok.Data;
import lombok.EqualsAndHashCode;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Data
@EqualsAndHashCode(exclude = "employeeList")
@Entity
@Table(name = "S_DEPT")
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "DEPT_ID")
    private Long deptId;

    @Column(length = 25, nullable = false)
    private String name;

    @OneToMany(mappedBy = "dept", cascade = {CascadeType.PERSIST})
    private List<Employee> employeeList = new ArrayList<>();
}
```

```
private static void dataDelete(EntityManagerFactory emf) {
    EntityManager em = emf.createEntityManager();
    em.getTransaction().begin();

    // 부서 검색
    Department department = em.find(Department.class, 1L);

    // 직원의 부서 정보 수정
    List<Employee> employeeList = department.getEmployeeList();
    for (Employee employee : employeeList) {
        employee.standby();
    }

    // 부서 삭제
    em.remove(department);

    em.getTransaction().commit();
    em.close();
}
```

<img width="169" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/0568a2c9-15ea-4a55-984b-da9e6381170f">
