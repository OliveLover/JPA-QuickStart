<h1>4. 다대일 연관관계 매핑</h1>

<h3>1. 연관관계 매핑 기준</h3>

|기준|설명|
|:---:|:---:|
|방향성<br />(Direction)|방향성은 단방향 관계와 양방향 관계가 있습니다.<br /> 예를 들어 직원(Employee)객체가 참조 변수를 통해 부서(Department) 객체를 참조하면 단반향입니다.<br />하지만 반대로 부서 객체도 참조 변수를 통해 직원 객체를 참조한다면 양방향이 됩니다. <br />중요한 것은 방향은 객체에만 존재하고 테이블은 항상 양방향이라는 것입니다.|
|다중성<br />(Multiplicity)|다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:N)관계가 있습니다.<br />예를 들어 여러 직원이 하나의 부서에 속해 있다면 직원과 부서의 관계는 다대일 관계입니다.<br />하지만 반대로 부서 입장에서 보면 일대다 관계가 됩니다.<br />그런데 직원이 여러 부서에 소속될 수 있다고 가정하면 다대다 관계로 바뀌게 됩니다.<br />이렇게 다중성은 비즈니스에 따라서 변경될 수 있습니다.|

<h3>2. 다대일 단방향 매핑</h3>

<h4>가정</h4>

```
직원(Employee)과 부서(Dempartment)가 있습니다.
직원 여러 명은 하나의 부서에 소속됩니다.
직원과 부서는 다대일(N : 1) 관계입니다.
직원을 조회했을 때, 직원이 속해 있는 부서 정보도 같이 조회됩니다.
반대로 부서를 통해서 직원 정보에 접근할 수 없습니다.
```
<h4>ERD Diagram</h4>
<img width="604" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/07883519-8dc9-4627-b938-dd0eb613fdcd">

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_DEPT")
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long deptId;

    @Column(length = 25, nullable = false)
    private String name;
}
```

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @ManyToOne
    @JoinColumn(name = "DEPT_ID")
    private Department dept;
}
```

<p><code>부서 테이블(S_DEPT)</code>과 매핑되는 <code>부서 객체</code>는 <code>직원(Employee) 객체</code>로 부터 참조 당하는 입장이기 때문에 연관관계 매핑과 관련해서 특별히 추가할 설정은 없습니다. </p>

<p><code>직원(Employee)</code> 클래스에서 가장 중요한 것은 <code>부서(Department)</code> 엔티티를 참조하는 <code>dept</code> 참조 변수 입니다. <code>@ManyToOne</code>은 <code>다(Many)</code>에 해당하는 엔티티가 <code>일(One)</code>에 해당하는 엔티티를 참조할 때 <code>다(Many)</code>에 해당하는 엔티티에 설정해야 합니다. </p>

<p><code>@JoinColumn</code>은 조인에 사용할 외래 키 칼럼을 매핑할 때 사용합니다. 위 설정대로라면 현재 <code>Employee</code>엔티티와 매핑된 <code>S_EMP</code>테이블에 <code>DEPT_ID</code> 칼럼을 외래 키로 설정한다는 의미입니다.</p>

<h4>@JoinColumn 생략 시 JPA 자동 네이밍 규칙</h4>

```
참조변수 이름 + '_' + 참조하는 테이블의 주 키 칼럼 이름
```

```
Hibernate:
  create table S_EMP (
    id bigint generated by default as identity,
    name varchar(25) not null,
    dept_DEPT_ID bigint,
    primary key (id)
  )
```

<h4>@ManyToOne 어노테이션이 지원하는 속성</h4>

|속성|기능|기본 값|
|:---:|:---|:---|
|optional|연관된 엔티티가 반드시 있어야 하는지 여부를 결정<br />false로 설정하면 항상 있어야 한다는 의미|true|
|fetch|글로벌 패치 전략을 설정<br />EAGER는 연관 엔티티를 동시에 조회하며, LAZY는 연관 엔티티를 실제 사용할 때 조회|@MantyToOne:EAGER<br />@OneToMany:LAZY|
|cascade|영속성 전이 기능을 설정<br />연관 엔티티를 같이 저장하거나 삭제할 때 사용||

<h3>3. 연관관계를 이용한 데이터 등록</h3>

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class ManyToOneOneWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
        em.persist(department);

        // 직원 등록
        Employee employee1 = new Employee();
        employee1.setName("개발부");
        employee1.setDept(department);
        em.persist(employee1);

        // 직원 등록
        Employee employee2 = new Employee();
        employee2.setName("도우너");
        employee2.setDept(department);
        em.persist(employee2);

        em.getTransaction().commit();
        em.close();
    }
}
```

<img width="176" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/a8eda718-f420-4256-87d0-7db17e9deee6">

<p>엔티티 클래스에 설정된 연관관계 매핑을 기반으로 실질적인 <code>SQL</code>을 생성하는 것은 <code>영속 컨테이너</code>입니다. <code>영속 컨테이너</code>는 관리 상태의 엔티티만 인지할 수 있기 때문에 당연히 연관관계에 참여하는 모든 엔티티는 관리 상태로 존재해야 합니다. 따라서 클라이언트는<code>직원(Employee)</code> 엔티티를 <code>등록(persist)</code>하기 전에 <code>부서(Depratment)</code> 엔티티를 먼저 관리 상태로 만든 것입니다. 그래야 <code>영속 컨테이너</code>가 직원 객체를 <code>관리 상태</code>로 만들 때 <code>부서 엔티티</code>를 이용할 수 있으며, 이런 관계를 바탕으로 <code>컨테이너</code>가 생성하는 <code>INSERT</code>구문에 <code>외래 키</code> 정보도 설정할 수 있는 것입니다.</p>

<p> <code>@JoinColumn</code> 설정으로 인해 <code>S_EMP</code>테이블에 <code>DEPT_ID</code> 칼럼이 추가되었다는 것과 <code>Employee</code>가 참조하는 <code>Department</code>객체의 식별자 값이 저장되었다는 것입니다. 결국 <cocde>@JoinColumn(name = "DEPT_ID")</cocde>는 <code>dept</code> 변수가 참조하는 <code>Department</code>객체의 식별자 값을 <code>외래 키</code>에 해당하는 <code>DEPT_ID</code>칼럼에 저장하라는 의미입니다.</p>

<h3>4. 연관관계를 이용한 데이터 검색</h3>

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class ManyToOneOneWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        Employee employee = em.find(Employee.class, 2L);
        System.out.println(employee.getName() + "의 부서 : " + employee.getDept().getName());
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
        em.persist(department);

        // 직원 등록
        Employee employee1 = new Employee();
        employee1.setName("개발부");
        employee1.setDept(department);
        em.persist(employee1);

        // 직원 등록
        Employee employee2 = new Employee();
        employee2.setName("도우너");
        employee2.setDept(department);
        em.persist(employee2);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate:
    select
        employee0_.id as id1_1_0_,
        employee0_.DEPT_ID as DEPT_ID3_1_0_,
        employee0_.name as name2_1_0_,
        department1_.DEPT_ID as DEPT_ID1_0_1_,
        department1_.name as name2_0_1_
    from
        S_EMP employee0_
    left outer join
        S_DEPT department1_
                on employee0_.DEPT_ID=department1_.DEPT_ID
    where
        employee_.id=?

도우너의 부서 : 개발부
```

<p>실행 결과를 보면 <code>EntityManager</code>의 <code>find</code>메소드가 호출될 때 <code>S_EMP</code> 테이블과 <code>S_DEPT</code>테이블이 조인으로 연결되는 것을 확인할 수 있습니다. 또한, <code>JDBC</code>의 복잡한 연관관계 매핑 코드들을 많이 줄일 수 있습니다.</p>

<h3>5. 외부 조인을 내부 조인으로 변경하기</h3>

<p><code>@ManyToOne</code>을 사용하여 연관관계를 매핑하면 <code>영속 컨테이너</code>는 기본적으로 <code>외부 조인(OUTER JOIN)</code>에 해당하는 쿼리를 생성합니다. 일반적으로 <code>외부 조인</code>은 조인 조건을 충족하지 못하는 데이터까지 조회 결과에 포함시킬 때 사용합니다. 따라서 조인 조건을 만족하는 데이터만 조회하는 경우에는 성능이 느린 <code>외부 조인(OUTER JOIN)</code>보다는 <code>내부 조인(INNER JOIN)</code>을 이용하는 것이 낫습니다.</p>
<p><code>@ManyToOne</code>을 이용한 다대일 매핑에서 <code>외부 조인</code>을 <code>내부 조인</code>으로 변경하기 위해서는 <code>optional</code> 속성을 이용하면 됩니다. <code>@ManyToOne</code>어노테이션에 <code>optional="true"</code>를 추가하면 <code>Employee.dept</code> 변수와 매핑되는 <code>DEPT_ID</code>칼럼도 반드시 <code>외래 키</code>에 해당하는 값이 저장되어야 합니다. 이 설정에 의해 <code>영속 컨테이너</code>는 <code>외부 조인</code>을 내부 조인으로 변경하여 쿼리를 제너레이션하는 것입니다.</p>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @ManyToOne(optional = false)
    @JoinColumn(name = "DEPT_ID")
    private Department dept;
}
```

```
Hibernate:
    select
        employee0_.id as id1_1_0_,
        employee0_.DEPT_ID as DEPT_ID3_1_0_,
        employee0_.name as name2_1_0_,
        department1_.DEPT_ID as DEPT_ID1_0_1_,
        department1_.name as name2_0_1_
    from
        S_EMP employee0_
    innerjoin
        S_DEPT department1_
            on employee0_DEPT_ID=department1_.DEPT_ID
    where
        employee0_.id=?
```

<h3>6. 페치 설정 변경하기</h3>

<p><code>@ManyToOne</code>은 <code>다(Many)</code>에 해당하는 직원 정보를 조회 했을 때, <code>일(One)</code>에 해당하는 부서 정보까지 같이 가져오기 위해서 조인 쿼리를 실행합니다.</p>
<p>하지만, 비즈니스 특성상 검색 결과에서 직원 정보만 사용하고 부서 정보는 사용하지 않는다면, 처음부터 사용하지 않을 부서 정보까지 모두 가져오는 것은 비효율적입니다. 이런 문제를 해결하기 위해서 <code>JPA</code>에서는 <code>fetch</code>속성을 지원합니다. <code>fetch</code>속성을 이용하면 연관관계에 있는 객체를 가져오는 시점을 결정할 수 있습니다.</p>

<h4>fetch 속성 값</h4>
<ul>
    <li><code>FetchType.EAGER</code> : 데이터를 조회할 때 연관된 데이터까지 같이 가져온다는 의미(default)</li>
    <li><code>FetchType.LAZY</code> : 실제 객체가 사용되는 시점까지 가져오는 시점을 지연시키라는 의미</li>
</ul>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @ManyToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "DEPT_ID")
    private Department dept;
}
```

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class ManyToOneOneWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        Employee employee = em.find(Employee.class, 2L);
        System.out.println(employee.getName() + " 직원이 검색됨");
//        System.out.println(employee.getName() + " 의 부서 : " +
                employee.getDept().getName());
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
        em.persist(department);

        // 직원 등록
        Employee employee1 = new Employee();
        employee1.setName("개발부");
        employee1.setDept(department);
        em.persist(employee1);

        // 직원 등록
        Employee employee2 = new Employee();
        employee2.setName("도우너");
        employee2.setDept(department);
        em.persist(employee2);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate:
    select
        employee0_.id as id_1_0_,
        employee0_.DETP_ID as DEPT_ID3_1_0_,
        employee0_.name as name2_1_0_
    from
        S_EMP employee0_
    where
        employee0_.id=?
```

<p>실행 결과를 보면 페치 설정을 <code>FetchType.LAZY</code>로 설정하면 <code>Employee</code>를 검색할 때, 내부적으로 조인을 사용하지 않습니다. <code>S_DEPT</code>테이블에 대한 검색도 일어나지 않았는데, 이는 클라이언트에서 부서 관련 데이터를 사용하지 않았기 때문입니다.</p>

```
import org.example.chapter04.domain.Department;
import org.example.chapter04.domain.Employee;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class ManyToOneOneWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        try {
            dataInsert(emf);
            dataUpdate(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataUpdate(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 신규 부서 등록
        Department department = new Department();
        department.setName("영업부");
        em.persist(department);

        // 부서 변경
        Employee employee = em.find(Employee.class, 1L);
        employee.setDept(department);
        em.getTransaction().commit();
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        Employee employee = em.find(Employee.class, 2L);
//        System.out.println(employee.getName() + " 직원이 검색됨");
        System.out.println(employee.getName() + " 의 부서 : " +
                employee.getDept().getName());
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 부서 등록
        Department department = new Department();
        department.setName("개발부");
        em.persist(department);

        // 직원 등록
        Employee employee1 = new Employee();
        employee1.setName("개발부");
        employee1.setDept(department);
        em.persist(employee1);

        // 직원 등록
        Employee employee2 = new Employee();
        employee2.setName("도우너");
        employee2.setDept(department);
        em.persist(employee2);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate:
    select
        employee0_.id as id1_1_0_,
        employee0_.DEPT_ID as DEPT_ID3_1_0_,
        employee0_.name as name2_1_0_
    from
        S_EMP employee0_
    where
        employee0_.id=?

Hibernate:
    select
        department0_.DEPT_ID as DEPT_ID1_0_0_,
        department0_.name as name2_0_0_
    from
        S_DEPT department0_
    where
        department0_.DEPT_ID=?

도우너 부서 : 개발부
```

<p><code>fetch</code> 속성을 <code>FetchType.LAZY</code>로 설정하면 연관 객체에 대한 <code>SELECT</code>를 실제 해당 객체가 사용되는 시점으로 미루기 때문에 검색과 관련해서 애플리케이션의 성능을 향상할 수 있습니다.</p>

<p>사실 <code>@ManyToOne</code>이나 <code>@OneToMany</code>를 설정할 때 연관데이터를 <code>즉시(EAGER)</code> 읽어올지, <code>지연(Lazy)</code>해서 읽어올지는 비즈니스의 상황에 따라 달라지기 때문에 페치 유형을 미리 결정하는 것은 비효율적입니다. 따라서 <code>페치 전략</code>은 기본적으로 <code>LAZY</code>로 설정해놓고 비즈니스의 특성에 따라서 <code>EAGER</code>로 변경하는 것이 좋습니다.</p>

<p>참고로 <code>@ManyToOne</code>은 <code>일(One)</code>에 해당하는 객체가 하나밖에 없으므로 <code>다(Many)</code>에 해당하는 객체를 조회했을 때, 일에 해당하는 객체를 조인을 통해 <code>즉시(EAGER)</code> 가져오는 것이 효율적일 수 있습니다. 그래서 <code>@ManyToOne</code>의 <code>fetch</code>속성은 기본값이 <code>FetchType.EAGER</code>로 되어있습니다.</p>

<p>하지만 일대다 관계를 매핑할 때 사용하는 <code>@OneToMany</code>는 <code>다(Many)</code>에 해당하는 객체가 컬렉션 형태로 여러 개 존재합니다. 따라서 연관 객체가 사용되는 시점에 <code>SELECT</code>를 처리하는 <code>FetchType.LAZY</code>가 기본 설정인 것입니다.</p>
