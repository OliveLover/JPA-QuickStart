<h1>5. 다양한 연관관계 매핑</h1>

<h3>1. 일대일 단방향 매핑</h3>

<p> 다중성 측면에서 일대일 관계는 관계에 참여하는 테이블이나 엔티티가 상대방에 대해서 하나의 관계만 가집니다. 방향성 측면에서 단방향은 하나의 엔티티에서만 다른 엔티티의 참조를 유지하도록 하는 것입니다.</p>

<h4>가정</h4>

```
사원증(EmployeeCard)과 직원(Employee)이 있습니다.
하나의 사원증은 한 명의 직원에 의해서만 소유될 수 있습니다.
사원증과 직원은 일대일 관계입니다.
사원증을 조회했을 때, 사원증을 소유한 직원 정보도 같이 사용할 수 있습니다.
반대로 사원을 통해서는 사원증 정보에 접근할 수는 없습니다.
```

<h4>ERD</h4>
<img width="595" alt="스크린샷 2024-07-06 오전 11 36 22" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/1be92bcf-2ac4-4fc3-92ba-33dc2cc84700">

<h4>Class Diagram</h4>

<p>객체 지향 관점에서 보면 직원을 통해 직원이 소유한 사원증을 사용할 수 있도록 하는 것이 더 적합할 수 있습니다. 아래는 객체지향적인 관점에서 작성한 클래스 다이어그램입니다.</p>

<img width="413" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/4852c637-4220-416a-b665-f52ed9a12708">

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;
}
```

```
import lombok.Data;

import javax.persistence.*;
import java.util.Date;

@Data
@Entity
@Table(name = "S_EMP_CARD")
public class EmployeeCard {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column
    private Long cardId;    // 사원증 아이디

    @Column(name = "EXPIRE_DATE")
    private Date expireDate;    // 사원증 만료 기간

    private String role;   // 권한

    @OneToOne
    @JoinColumn(name = "EMP_CARD_ID")
    private Employee employee;
}
```

```
import org.example.chapter05.domain.Employee;
import org.example.chapter05.domain.EmployeeCard;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.text.ParseException;
import java.text.SimpleDateFormat;

public class OneToOneOneWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf =
                Persistence.createEntityManagerFactory("Chapter05");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();

        EmployeeCard employeeCard = em.find(EmployeeCard.class, 1L);
        System.out.println("검색된 사원증 번혼 : " + employeeCard.getCardId());
        System.out.println("권한 : " + employeeCard.getRole());
        System.out.println("사원증 소유자 : " + employeeCard.getEmployee().getName());
    }

    private static void dataInsert(EntityManagerFactory emf) throws ParseException {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 직원 등록
        Employee employee = new Employee();
        employee.setName("둘리");
        em.persist(employee);

        // 사원증 등록
        EmployeeCard card = new EmployeeCard();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        card.setExpireDate(dateFormat.parse("2025-12-31"));
        card.setRole("MASTER");
        // 직원에 대한 참조 설정
        card.setEmployee(employee);

        em.persist(card);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate: 
    
    create table S_EMP_CARD (
       cardId bigint generated by default as identity,
        EXPIRE_DATE timestamp,
        role varchar(255),
        EMP_CARD_ID bigint,
        primary key (cardId)
    )
Hibernate: 
    
    alter table S_EMP_CARD 
       add constraint FKktkkxy8rry12gqixjk25ws9k3 
       foreign key (EMP_CARD_ID) 
       references S_EMP

Hibernate: 
    insert 
    into
        S_EMP
        (id, name) 
    values
        (default, ?)
Hibernate: 
    insert 
    into
        S_EMP_CARD
        (cardId, EMP_CARD_ID, EXPIRE_DATE, role) 
    values
        (default, ?, ?, ?)
Hibernate: 
    select
        employeeca0_.cardId as cardid1_1_0_,
        employeeca0_.EMP_CARD_ID as emp_card4_1_0_,
        employeeca0_.EXPIRE_DATE as expire_d2_1_0_,
        employeeca0_.role as role3_1_0_,
        employee1_.id as id1_0_1_,
        employee1_.name as name2_0_1_ 
    from
        S_EMP_CARD employeeca0_ 
    left outer join
        S_EMP employee1_ 
            on employeeca0_.EMP_CARD_ID=employee1_.id 
    where
        employeeca0_.cardId=?
검색된 사원증 번혼 : 1
권한 : MASTER
사원증 소유자 : 둘리
```

<p> 클라이언트를 실행했을 때 <code>사원증(S_EMP_CARD)</code>테이블에 <code>EMP_CARD_ID</code>라는 외래 키 칼럼이 포함되고 그에 해당하는 제약조건도 적절히 설정되는 것을 확인할 수 있습니다.</p>

<p>실행된 검색 쿼리는 <code>사원증(S_EMP_CARD)</code>과 <code>사원(S_EMP)</code> 테이블을 <code>외부 조인</code>으로 연결하고 있습니다. </p>

<img width="365" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/ded5abf0-47a6-4ea8-9750-242d9735777b">

<h4>외부 조인을 내부 조인으로 변경하기</h4>

<p>외부 조인은 내부 조인보다 성능이 떨어집니다. 일대일 단방향 매핑 설정은 기본적으로 외부 조인으로 처리됩니다. <code>@OneToOne</code>어노테이션에 <code>optional</code>속성을 추가합니다.</p>

```
import lombok.Data;

import javax.persistence.*;
import java.util.Date;

@Data
@Entity
@Table(name = "S_EMP_CARD")
public class EmployeeCard {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column
    private Long cardId;    // 사원증 아이디

    @Column(name = "EXPIRE_DATE")
    private Date expireDate;    // 사원증 만료 기간

    private String role;   // 권한

    @OneToOne(optional = false)
    @JoinColumn(name = "EMP_CARD_ID")
    private Employee employee;
}
```

```
Hibernate: 
    select
        employeeca0_.cardId as cardid1_1_0_,
        employeeca0_.EMP_CARD_ID as emp_card4_1_0_,
        employeeca0_.EXPIRE_DATE as expire_d2_1_0_,
        employeeca0_.role as role3_1_0_,
        employee1_.id as id1_0_1_,
        employee1_.name as name2_0_1_ 
    from
        S_EMP_CARD employeeca0_ 
    inner join
        S_EMP employee1_ 
            on employeeca0_.EMP_CARD_ID=employee1_.id 
    where
        employeeca0_.cardId=?
검색된 사원증 번혼 : 1
권한 : MASTER
사원증 소유자 : 둘리
```

<h4>페치 전략 변경하기</h4>

<p><code>@OneToOne</code>은 <code>@ManyToOne</code>과 마찬가지로 연관관계에 있는 객체가 하나이므로 <code>fetch</code> 속성에 대한 기본 설정이 <code>FetchType.EAGER</code>로 되어 있습니다. 따라서 사원증을 조회했을 때 무조건 쿼리가 실행되어 연관된 직원 객체도 같이 조회 되었습니다.</p>

```
import lombok.Data;

import javax.persistence.*;
import java.util.Date;

@Data
@Entity
@Table(name = "S_EMP_CARD")
public class EmployeeCard {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "CARD_ID")
    private Long cardId;    // 사원증 아이디

    @Column(name = "EXPIRE_DATE")
    private Date expireDate;    // 사원증 만료 기간

    private String role;   // 권한

    @OneToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "EMP_CARD_ID")
    private Employee employee;
}
```

```
Hibernate: 
    select
        employeeca0_.CARD_ID as card_id1_1_0_,
        employeeca0_.EMP_CARD_ID as emp_card4_1_0_,
        employeeca0_.EXPIRE_DATE as expire_d2_1_0_,
        employeeca0_.role as role3_1_0_ 
    from
        S_EMP_CARD employeeca0_ 
    where
        employeeca0_.CARD_ID=?
검색된 사원증 번혼 : 1
권한 : MASTER
Hibernate: 
    select
        employee0_.id as id1_0_0_,
        employee0_.name as name2_0_0_ 
    from
        S_EMP employee0_ 
    where
        employee0_.id=?
사원증 소유자 : 둘리
```

<p>실행 결과를 보면 클라이언트가 사원증에 대한 정보만 사용하는 경우에은 <code>S_EMP_CARD</code>테이블만 조회합니다. 그러다 직원 이름을 출력하는 순간 <code>S_EMP</code>테이블을 조회하는 것을 확인할 수 있습니다.</p>

<h3>2. 일대일 양방향 매핑</h3>

<p>다대일 관계에서는 자식 테이블에 해당하는 <code>다(Many)</code>쪽에서 외래 키를 가지도록 했습니다. 그래서 다대일 관계를 양방향으로 변환할 때, 자연스럽게 <code>다(Many)</code>에 해당하는 엔티티를 연관관계의 소유자로 설정할 수 있었습니다. 하지만 일대일 관계에서는 어느 쪽에서든 외래 키를 가질 수 있기 때문에 두 테이블 중에 어떤 테이블에서 외래키를 가지게 할지 결정해야 합니다. 외래 키의 위치가 중요한 이유는 외래 키를 기준으로 양방향 연관관계 매핑에서 소유자를 결정할 수 있기 때문입니다.</p>

<p>일대일 단반향을 양방향으로 매핑으로 변경하기 위해서 다음과 같은 조건을 가정합니다.</p>

```
사원증(Employee)과 직원(Employee)이 있습니다.
하나의 사원증은 한 명의 직원에 의해서만 소유될 수 있습니다.
사원증과 직원은 일대일 관계입니다.
사원증을 조회했을 때, 사원증을 소유한 직원 정보도 사용할 수 있습니다.
반대로 직원 정보를 조회했을 때, 직원이 소유한 사원증 정보도 같이 사용하라 수있습니다.
```

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @OneToOne(mappedBy = "employee")
    private EmployeeCard card;
}
```

<p>양방향 매핑에서는 매핑에 참여하는 두 엔티티 중 하나를 반드시 소유자로 지정해야 합니다. 다대일 양방향 매핑에서 확인했듯이 <code>일반적으로 외래키를 소유한 엔티티가 연관관계의 소유자</code>가 됩니다. 따라서 현재 <code>S_EMP_CARD</code>테이블에 외래 키가 설정되어 있기 때문에 <code>EmployeeCard</code>가 연관관계의 소유자가 됩니다. 따라서 소유자가 아닌 <code>Employee</code>에는 <code>mappedBy</code>속성을 추가하여 자신이 소유자가 아님을 <code>영속 컨테이너</code>에게 알려줘야 합니다.</p>

```
import org.example.chapter05.domain.Employee;
import org.example.chapter05.domain.EmployeeCard;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.text.ParseException;
import java.text.SimpleDateFormat;

public class OneToOneBothWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf =
                Persistence.createEntityManagerFactory("Chapter05");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();

        // 검색된 사원증을 통해 직원 정보 사용하기
        EmployeeCard employeeCard = em.find(EmployeeCard.class, 1L);
        System.out.println("사원증 유효기간 : " + employeeCard.getExpireDate());
        System.out.println("사원증 소유자 : " + employeeCard.getEmployee().getName());

        // 검색된 직원을 통해 사원증 정보 사용하기
        Employee employee = em.find(Employee.class, 1L);
        System.out.println("사원증 소유자 : " + employee.getName());
        System.out.println("사원증 유효기간 : " + employee.getCard().getExpireDate());
    }

    private static void dataInsert(EntityManagerFactory emf) throws ParseException {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 직원 등록
        Employee employee = new Employee();
        employee.setName("둘리");
        em.persist(employee);

        // 사원증 등록
        EmployeeCard card = new EmployeeCard();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        card.setExpireDate(dateFormat.parse("2025-12-31"));
        card.setRole("MASTER");
        // 직원에 대한 참조 설정
        card.setEmployee(employee);

        em.persist(card);

        em.getTransaction().commit();
        em.close();
    }
}
```

<p>작성된 클라이언트 소스에서 <code>dataSelect</code> 메소드를 보면 먼저 <code>사원증(EmployeeCard)</code>객체를 검색하고, <code>참조 변수(EmployeeCard.employee)</code>를 통해 직원 정보를 사용하고 있습니다. 그리고 그 아래에는 반대로 <code>직원(Employee)</code> 객체를 검색한 후에 <code>참조 변수(Employee.card)</code>를 통해 사원증 객체를 사용하고 있습니다. 이렇게 양방향 매핑으로 설정된 객체들은 어떤 객체를 검색하더라도 반대쪽 객체를 같이 사용할 수 있습니다.</p>

<h4>순수한 객체로서의 양방향 참조</h4>

<p><code>OneToOneBothWayClient</code>의 <code>dataInsert</code> 메소드를 보면 사워 객체를 생성한 후에 직원 객체를 할당했습니다. 따라서 사원증을 통해 직원 정보를 접근했을 때는 문제가 되지 않습니다. 그런데 <code>직원 객체의 참조 변수(Employee.card)</code>에는 사원증 객체가 할당되지 않았기 때문에 직원 객체를 통해 사원증 객체를 사용하려고 하면, 예외가 발생합니다.</p>


```
public class OneToOneBothWayClient {
(...)

    private static void dataInsert(EntityManagerFactory emf) throws ParseException {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 직원 등록
        Employee employee = new Employee();
        employee.setName("둘리");
        em.persist(employee);

        // 사원증 등록
        EmployeeCard card = new EmployeeCard();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        card.setExpireDate(dateFormat.parse("2025-12-31"));
        card.setRole("MASTER");
        // 직원에 대한 참조 설정
        card.setEmployee(employee);

        em.persist(card);

        em.getTransaction().commit();
        em.close();

        System.out.println("사원증을 통한 직원 정보 접근 : " + card.getEmployee().getName());
        System.out.println("직원을 통한 사원증 정보 접근 : " + employee.getCard().getExpireDate());
    }
}
```

<p>수정된 클라이언트를 실행하면 사원증 객체를 통한 직원 정보 접근은 가능하지만 반대인 직원 객체를 통한 사원증 정보 사용은 불가능하기 때문에 <code>NullPointerException</code>이 발생합니다. 따라서 <code>EmployeeCard</code>클래스에 양방향 참조 메소드를 추가하여 사원증에 직원에 대한 참조를 설정할 때, 자동으로 상호 간 참조가 이루어지도록 해야합니다.</p>

```
import lombok.Data;

import javax.persistence.*;
import java.util.Date;

@Data
@Entity
@Table(name = "S_EMP_CARD")
public class EmployeeCard {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "CARD_ID")
    private Long cardId;    // 사원증 아이디

    @Column(name = "EXPIRE_DATE")
    private Date expireDate;    // 사원증 만료 기간

    private String role;   // 권한

    @OneToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "EMP_CARD_ID")
    private Employee employee;

    public void setEmployee(Employee employee) {
        this.employee = employee;
        employee.setCard(this);
    }
}
```

```
사원증 소유자 : 둘리
사원증 유효기간 : 2025-12-31 00:00:00.0
```

<h4>순환참조 문제 해결</h4>

<p>양방향 참조에서는 순수한 객체 상태에서의 양방향 참조도 신경 써야 하지만 순화 참조 문제도 고려해야 합니다. 현재 작성한 클라이언트(OneToOneBothWayClinet)에서는 각자가 참조하는 상대 객체의 특정 변수만 사용하기 때문에 문제가 없습니다.</p>

```
System.out.println("사원증을 통한 직원 정보 접근 : " + card.getEmployee().getName());
System.out.println("직원을 통한 사원증 정보 접근 : " + employee.getCard().getExpireDate());
```

<p>하지만 만약 모든 변수 값을 확인하기 위해서 <code>toString</code>메소드를 호출하면 순환참조 문제가 발생됩니다.</p>

```
public class OneToOneBothWayClient {

    (...)

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();

        // 검색된 사원증을 통해 직원 정보 사용하기
        EmployeeCard employeeCard = em.find(EmployeeCard.class, 1L);
        System.out.println("사원증을 통한 직원 정보 접근 : " + employeeCard.toString());

    (...)
}
```

<img width="954" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/297181c5-4616-4008-bd2b-33b59c08ee48">

<p>수정된 클라이언트를 실행하면 순환참조에 의해서 다음과 같이 <code>java.lang.StackOverflowError</code>가 발생하는 것을 확인할 수 있습니다.</p>

<p>이런 순환참조 문제를 해결하기 위해서는 롬복이 생성하는 <code>toString</code> 메소드에서 순환참조에 사용되는 참조 변수를 제외시켜야 합니다. 이는 마치 <code>EqualsAndHashCode</code>어노테이션에서 순환 참조 문제를 해결하기 위해 <code>exclude</code>속성을 이용했던 것과 같은 개념으로 이해할 수 있습니다.</p>

```
import lombok.Data;
import lombok.ToString;

import javax.persistence.*;
import java.util.Date;

@Data
@ToString(exclude = "employee")
@Entity
@Table(name = "S_EMP_CARD")
public class EmployeeCard {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "CARD_ID")
    private Long cardId;    // 사원증 아이디

    @Column(name = "EXPIRE_DATE")
    private Date expireDate;    // 사원증 만료 기간

    private String role;   // 권한

    @OneToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "EMP_CARD_ID")
    private Employee employee;

    public void setEmployee(Employee employee) {
        this.employee = employee;
        employee.setCard(this);
    }
}
```

<p>이제 <code>EmployeeCard</code> 클래스 위에 선언된 <code>@ToString</code>은 롬복에게 <code>toString</code>메소드를 재정의할 때, <code>employee</code> 변수는 <code>toString</code>메소드에 포함시키지 않습니다.</p>

<h4>반대 방향으로의 연관관계 매핑</h4>

<p>일대일 연관관계에는 반대도 당연히 일대일 관계이므로 지금까지의 설정과 반대로 부모 테이블 쪽에 외래 키를 두는 것도 가능합니다. 그리고 이 상황이 자바 프로그래밍을 오래 해본 개발자들에게는 오히려 자연스러운 설정일 수 있습니다.</p>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @OneToOne(optional = false , fetch = FetchType.LAZY)
    @JoinColumn(name = "EMP_CARD_ID")
    private EmployeeCard card;

    public void setEmployeeCard(EmployeeCard card) {
        this.card = card;
        card.setEmployee(this);
    }
}
```

<p>이전과 반대로 <code>Employee</code>클래스에 <code>EmployeeCard</code> 객체를 참조할 <code>card</code>변수를 추가했습니다. 그리고 <code>@OneToOne</code>어노테이션을 설정했으며, <code>@JoinColumn</code>을 이용하여 <code>S_EMP</code> 테이블에 추가할 외래 키 칼럼 이름도 지정했습니다. 그리고 아래쪽에는 두 객체들이 상호 간에 참조 정보를 유지할 수 있도록 양방향 참조 메소드(setEmployeeCard)도 추가했습니다.</p>

```
import lombok.Data;
import lombok.ToString;

import javax.persistence.*;
import java.util.Date;

@Data
@ToString(exclude = "employee")
@Entity
@Table(name = "S_EMP_CARD")
public class EmployeeCard {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "CARD_ID")
    private Long cardId;    // 사원증 아이디

    @Column(name = "EXPIRE_DATE")
    private Date expireDate;    // 사원증 만료 기간

    private String role;   // 권한

    @OneToOne(mappedBy = "card")
    private Employee employee;
}
```

<p><code>EmployeeCard</code>는 연관관계에서 소유자가 아니기 때문에 <code>@OneToOne</code>어노테이션에 <code>mappedBy</code>속성을 추가하여 본인은 연관관계의 주인이 아님을 선언했고, <code>mappedBy</code>속성 값으로 <code>연관관계 주인(Employee)</code>쪽의 <code>참조 변수(card)</code>를 지정했습니다.</p>

```
import org.example.chapter05.domain.Employee;
import org.example.chapter05.domain.EmployeeCard;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.text.ParseException;
import java.text.SimpleDateFormat;

public class OneToOneBothWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf =
                Persistence.createEntityManagerFactory("Chapter05");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();


        Employee employee = em.find(Employee.class, 1L);
        System.out.println("사원증을 통한 직원 정보 접근 : " + employee.getCard().toString());
    }

    private static void dataInsert(EntityManagerFactory emf) throws ParseException {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 사원증 등록
        EmployeeCard card = new EmployeeCard();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        card.setExpireDate(dateFormat.parse("2025-12-31"));
        card.setRole("MASTER");
        em.persist(card);

        // 직원 등록
        Employee employee = new Employee();
        employee.setName("둘리");
        // 사원증에 대한 참조 설정
        employee.setEmployeeCard(card);
        em.persist(employee);


        em.getTransaction().commit();
        em.close();
    }
}
```

|S_EMP_CARD 테이블에 외래 키(이전 상황)|S_EMP 테이블에 외래 키 (지금 상황)|
|---|---|
|<img width="375" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/d9846598-0509-467d-adfd-58b81333510c">|<img width="295" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/dc687089-993a-4b50-a729-f018cbe9a2c4">|

<h3>3. 부모 키를 공유하는 일대일 매핑</h3>

<p>지금까지는 부모 테이블의 기본 키를 자식 테이블에서 외래 키로만 사용하는 일대일 관계를 살펴봤습니다. 그런데 일대일 관계를 매핑하다보면 부모 테이블의 기본키를 자식 테이블에서 외래 키와 동시에 자식 테이블의 기본 키로도 사용하는 경우가 있습니다.</p>

<p>예를 들어 직원 테이블의 기본 키는 <code>직원 아이디(ID)</code>칼럼이고, 사원증 테이블의 기본 키는 <code>사원증 아이디(EMP_ID)</code>칼럼입니다. 부모 키를 공유하는 일대일 관계는 직원의 아이디와 사원증 아이디가 동일한 상태를 의미합니다. 이 경우, 사원증 테이블은 다음 그림과 같이 <code>직원(S_EMP)</code> 테이블과 동일한 값을 가지는 <code>칼럼(EMP_ID)</code> 기본 키로 사용하는 동시에 외래 키로도 사용합니다.</p>

<h4>ERD</h4>

<img width="557" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/b90a8a6d-d9a9-4d6f-8a2d-37207fb62be0">

<h4>Class Diagram</h4>

<img width="429" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/baa7bd17-7433-4cc6-afbe-7ba080a3473d">

<p><code>S_EMP_CARD</code>테이블과 맾ㅇ된 <code>EmployeeCard</code>엔티티는 <code>Employee</code>타입의 변수를 멤버 변수로 가지며, <code>Employee</code>객체를 참조하는 일대일 관계를 맺게 됩니다. 이렇게 부모 키를 공유하며 자식의 기본 키와 동시에 외래 키로 사용하는 일대일 관계를 매핑하기 위해서는 <code>@MapsId</code>라는 특별한 어노테이션을 사용해야 합니다.</p>

```
import lombok.Data;
import lombok.ToString;

import javax.persistence.*;
import java.util.Date;

@Data
@ToString(exclude = "employee")
@Entity
@Table(name = "S_EMP_CARD")
public class EmployeeCard {

    @Id
    @Column(name = "CARD_ID")
    private Long cardId;    // 사원증 아이디

    @Column(name = "EXPIRE_DATE")
    private Date expireDate;    // 사원증 만료 기간

    private String role;   // 권한

    @MapsId
    @OneToOne
    @JoinColumn(name = "EMP_ID")
    private Employee employee;
}
```

<p><code>EmployeeCard</code> 클래스에서 가장 먼저 주목할 부분은 <code>cardId</code>변수에 선언했던 <code>GeneratedValue</code>가 삭제된 것입니다. 이는 <code>@GeneratedValue</code>에 의해서 자동으로 증가된 식별자 값을 사용하지 않고, 부모 엔티티인 <code>Employee</code>객체의 식별자 값을 같이 사용하기 위함입니다.</p>

<p>그리고 <code>employee</code>변수에 일대일 매핑을 위해 <code>@OneToOne</code>, <code>@JoinColumn</code>, <code>@MapsId</code>를 설정했습니다. 먼저 <code>@JoinColumn(name = "EMP_ID")</code>은 <code>EmployeeCard</code>와 매핑된 <code>S_EMP_CARD</code>테이블에 <code>EMP_ID</code>칼럼을 추가하여 외래 키 칼럼으로 사용하라는 의미입니다. 그런데 <code>@JoinColumn</code>위에 <code>@MapsId</code>라는 새로운 어노테이션을 추가했는데, <code>@MapsId</code>는 <code>JoinColumn</code>으로 매핑한 외래 키 칼럼을 기본 키 칼럼으로도 사용하겠다는 의미의 설정입니다.</p>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

}
```

```
import org.example.chapter05.domain.Employee;
import org.example.chapter05.domain.EmployeeCard;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.text.ParseException;
import java.text.SimpleDateFormat;

public class OneToOneOneWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf =
                Persistence.createEntityManagerFactory("Chapter05");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        EmployeeCard employeeCard = em.find(EmployeeCard.class, 1L);
        System.out.println("검색된 사원증 번혼 : " + employeeCard.getCardId());
        System.out.println("권한 : " + employeeCard.getRole());
        System.out.println("사원증 소유자 : " + employeeCard.getEmployee().getName());
    }

    private static void dataInsert(EntityManagerFactory emf) throws ParseException {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 직원 등록
        Employee employee = new Employee();
        employee.setName("둘리");
        em.persist(employee);

        // 사원증 등록
        EmployeeCard card = new EmployeeCard();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        card.setExpireDate(dateFormat.parse("2025-12-31"));
        card.setRole("MASTER");
        card.setEmployee(employee);
        em.persist(card);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate: 
    
    create table S_EMP (
       id bigint generated by default as identity,
        name varchar(25) not null,
        primary key (id)
    )
Hibernate: 
    
    create table S_EMP_CARD (
       EMP_ID bigint not null,
        EXPIRE_DATE timestamp,
        role varchar(255),
        primary key (EMP_ID)
    )
Hibernate: 
    
    alter table S_EMP_CARD 
       add constraint FKgvqnf20bcuno9ssgeysu0uoc 
       foreign key (EMP_ID) 
       references S_EMP
```

<p>실행 결과를 보면 <code>S_EMP_CARD</code>테이블에 <code>EMP_ID</code>가 기본 키로 사용되면서 동시에 <code>S_EMP</code>테이블의 기본 키인 <code>ID</code>를 참조하는 외래 키로도 사용되고 있는 것을 확인할 수 있습니다.</p>

<img width="270" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/de59eeb3-4539-4e29-8ffd-520ffb7577e8">

<h4>양방향 매핑 설정</h4>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @OneToOne(mappedBy = "employee")
    private EmployeeCard card;

    public void setEmployeeCard(EmployeeCard card) {
        this.card = card;
        card.setEmployee(this);
    }
}
```

<p>수정된 <code>Employee</code>에는 사원증 객체를 참조하는 참조 변수가 추가 됐고, 변수 위에 <code>@OneToOne</code>을 설정했습니다. 그리고 <code>Employee</code>는 양방향 매핑에서 소유자가 아니므로 <code>@OneToOne</code>어노테이션에 <code>mappedBy</code>속성을 추가했습니다. 마지막으로 <code>setEmployeeCard</code>메소드를 통해 단순한 객체 상태에서도 양방향 참조가 가능하도록 했습니다.</p>

```
import org.example.chapter05.domain.Employee;
import org.example.chapter05.domain.EmployeeCard;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.text.ParseException;
import java.text.SimpleDateFormat;

public class OneToOneBothWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf =
                Persistence.createEntityManagerFactory("Chapter05");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();

        EmployeeCard employeeCard = em.find(EmployeeCard.class, 1L);
        System.out.println("검색된 사원증 번호 : " + employeeCard.getCardId());
        System.out.println("권한 : " + employeeCard.getRole());
        System.out.println("사원증 소유자 : " + employeeCard.getEmployee().getName());

        Employee employee = em.find(Employee.class, 1L);
        System.out.println("검색된 직원 이름 : " + employee.getName());
        System.out.println("직원이 소유한 사원증 권한 : " + employee.getCard().getRole());
    }

    private static void dataInsert(EntityManagerFactory emf) throws ParseException {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 직원 등록
        Employee employee = new Employee();
        employee.setName("둘리");
        em.persist(employee);

        // 사원증 등록
        EmployeeCard card = new EmployeeCard();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        card.setExpireDate(dateFormat.parse("2025-12-31"));
        card.setRole("MASTER");
        // 직원에 대한 참조 설정
        card.setEmployee(employee);
        em.persist(card);

        em.getTransaction().commit();
        em.close();
    }
}
```

<p><code>dataInsert</code>메소드에서 객체 등록 순서를 변경했습니다. 즉, 사원증을 먼저 등록했던 코드를 직원을 먼저 등록하고 등록된 직원을 사원증 객체에 할당하도록 수정해야 합니다.</p>

<h3>4. 다대다 연관관계 매핑</h3>

<p>관계형 데이터베이스에서는 다대다 관계를 표현할 수 없기 때문에 반드시 다대다 관계를 일대다, 다대일로 풀어주는 연결 테이블이 필요합니다. 하지만 객체지향은 다대다 관계에 있는 두 객체에 대해서 연결 클래스를 만들 수도 있고, 연결 클래스 없이 컬렉션을 기반으로 직접 다대다 관계를 처리할 수도 있습니다. 다대다 관계를 매핑하려면 가장 먼저 연결 클래스를 어떻게 처리할 것인지부터 결정해야 합니다.</p>

<p>연결 클래스에 대한 결정이 끝나면 두 번째는 연결 테이블의 기본 키 전략에 대한 고민이 필요합니다. 연결 테으블 역시 테이블이기 때문에 검색을 위해서는 기본키가 필요한데 연결 테이블의 기본 키를 결정하는 것은 다소 복잡할 수 있습니다. 우선 양쪽 테이블의 기본 키를 받아서 외래 키와 동시에 복합 키로 사용할 수도 있고, 양쪽 테이블의 기본 키를 외래 키로만 사용하고 연결 테이블을 위한 별도의 키를 만들어서 사용할 수도 있기 때문입니다. 이렇든 다대다 연관관계는 고민해야 할 부분들이 많은 복잡한 관계입니다.</p>

<h4>연결 클래스를 만든다 vs 만들지 않는다.</h4>

<h4>다대다 연관관계 ERD</h4>

<p><code>주문(S_ORD)</code>과 <code>상품(S_PRODUCT)</code> 테이블을 가정해보겠습니다. 우선 데이터 베이스 관점에서 보면 두 테이블을 연결하는 <code>주문 내역(S_TIEM)</code> 테이블이 필요합니다. 그리고 주문과 주문내역 테이블을 <code>일대다</code>로, 주문내역과 상품은 <code>다대일</code>관계로 연결하면 됩니다.</p>

<img width="702" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/259c890c-77a4-482b-9ae0-5142bf6de896">


<h4>연결 클래스가 없는 다대다 관계</h4>

<p>하지만 관계형 데이터베이스와 달리 객체지향에서는 중간의 연결 클래스 없이 컬렉션을 기반으로 다대다 관계를 직접 매핑할 수 있습니다. </p>

<img width="443" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/c20b2ced-b0a6-46d5-9c24-b2ec1c5ddf26">

<p><code>JPA</code>에서 이렇게 연결 엔티티를 만들지 않고 다대다 관계를 직접 매핑하려면 <code>@JoinTable</code>이라는 어노테이션을 사용합니다. </p>

<h4>연결 클래스가 있는 다대다 관계</h4>

<p>아래의 그림처럼 <code>연결 테이블(S_ITEM)</code>과 매핑되는 <code>Item</code>이라는 엔티티 클래스를 별도로 만들어서 <code>주문(Order)</code>과 <code>주문내역(Item)</code>을 일대다로 매핑하고 <code>주문내역</code>과 <code>상품(Product)</code>을 다대일 관계로 매핑할 수도 있습니다.</p>

<img width="695" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/c366de7e-55d3-4046-927b-48f27b6ae016">

<p>이 두 가지 방법 중에서 어떤 방법을 선택하든 상관 없습니다. 두번째 방법은 관리 대상 클래스가 늘어나는 문제가 있지만, 별도의 연결 클래스를 만들면 가독성을 높일 수도 있고 이후에 기능을 확장할 때도 좀 더 편리합니다.</p>

<h4>식별 관계 vs 비식별관계</h4>

<p>다대다 연관관계 매핑에서는 연결 테이블의 기본 키를 어떻게 처리할 것인지에 대해서도 결정해야 합니다. 예를 들어 주문과 상품 테이블을 연결하는 주문내역 테이블을 연결하는 주문내역 테이블은 당연히 양쪽의 두 테이블의 기본 키를 외래 키 형태로 가지게 되는데, 중요한 것은 주문내역 테이블도 결국 테이블이기 때문에 데이터를 검색하기 위해서는 반드시 기본키가 필요합니다.</p>

<h4>식별관계(Identifying Relationship)</h4>

<p>연결 테이블의 기본 키 전략중에서 첫 번째는 다음 그림과 같이 두 외래 키를 결합하여 복합키로 사용하는 것입니다. 다시 말하면 <code>S_ORD</code>테이블에서 받은 <code>ORD_ID</code>와 <code>S_PRODUCT</code>테이블에서 받은 <code>PRODUCT_ID</code>를 외래 키와 동시에 복합 키형태의 기본 키로 사용합니다.</p>

<img width="702" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/9635993a-776f-404b-a696-662494584945">

<p><code>주문내역 테이블(S_ITEM)</code>에서는 <code>ORD_ID</code>나 <cocde>PRODUCT_ID</cocde>중 하나만을 기본 키로 사용할 수 없습니다. 두 칼럼 모두 중복되는 값이 저장되기 때문입니다. 결국 <code>ORD_ID</code>와 <code>PRODUCT_ID</code>를 결합하여 복합키 형태로 사용해야 하는데, 이렇게 외래키를 결합하여 복합 키로 사용하는 것을 <code>식별관계(Identifying Relationship)</code>라고 합니다.</p>

<h4>비식별관계(Non Identifying Relationship)</h4>

<p>비식별관계는 다른 테이블의 기본 키를 연결 테이블에서 외래 키로만 사용합니다. 그리고 연결 테이블만을 위한 별도의 기본 키를 추가해서 사용합니다. 이렇게 비식별관계를 사용하면 식별자 값을 자동으로 증가시킬 수도 있고 키 관리 측면에서 식별관계보다 훨씬 편합니다.</p>

<img width="726" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/9d7c14ee-48ff-4e3a-9b46-c9ee5c986c2e">

<h3>5. 연결 클래스를 사용하지 않는 다대다 매핑</h3>

<p>다대다 매핑에서는 <code>@ManyToMany</code>와 <code>@JoinTable</code>을 사용해서 연결 엔티티 없이 연결 테이블을 직접 매핑할 수 있습니다. 따라서 연결 테이블인 <code>주문상품(S_ITEM)</code>테이블과 매핑할 <code>주문내역 클래스</code>를 별도로 정의하지 않고 연관관계 매핑을 처리할 수 있습니다.</p>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_PRODUCT")
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;        // 상품 아이디

    private String name;    // 상품 이름

    @Column(name = "SHORT_DESC")
    private String shortDesc;   // 상품 설명

    private String category;    // 카테고리
}
```

```
import lombok.Data;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

@Data
@Entity
@Table(name = "S_ORD")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;            // 주문 아이디

    @Column(name = "CUSTOMER_ID")
    private Long customerId;    // 고객 아이디

    @Column(name = "ORDER_DATE")
    private Date orderDate;     // 주문 날짜

    private Double total;       // 주문 금액

    @ManyToMany
    @JoinTable(name = "S_ITEM"
            , joinColumns = @JoinColumn(name = "ORD_ID")
            , inverseJoinColumns = @JoinColumn(name = "PRODUCT_ID")
            , uniqueConstraints = @UniqueConstraint(columnNames = {"ORD_ID", "PRODUCT_ID"})
    )
    private List<Product> productList = new ArrayList<>();
}
```

|속성|의미|
|---|---|
|name|연결 테이블의 이름을 지정|
|joinColumns|연결 테이블(S_ITEM)에서 현재 엔티티(Order)와 매핑된 테이블(S_ORD)을 참조할 외래 키 칼럼을 지정|
|inverseJoinColumns|연결 테이블(S_ITEM)에서 현재 엔티티와 반대되는 상품(S_PRODUCT) 테이블을 참조할 외래 키 칼럼을 지정|
|uniqueConstraints|유일(Unique)키 제약조건을 추가|

```
import org.example.chapter05.domain.Order;
import org.example.chapter05.domain.Product;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.util.Date;
import java.util.List;

public class ManyToManyOneWayNoRelationEntityClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter05");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();

        // 검색한 Order를 통해 Product 목록을 출력한다.
        Order order = em.find(Order.class, 1L);
        System.out.println(order.getId() + "번 주문에 대한 상품 목록");

        List<Product> productList = order.getProductList();
        for (Product product : productList) {
            System.out.println("---> " + product.getName());
        }
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 1번 상품 목록
        Product product1 = new Product();
        product1.setName("LG 통돌이 세탁기");
        em.persist(product1);

        // 2번 상품 등록
        Product product2 = new Product();
        product2.setName("다이슨 청소기");
        em.persist(product2);

        // 1번 주문 등록
        Order order = new Order();
        order.setOrderDate(new Date());
        // 주문 객체가 가진 상품 목록(productList)에 상품 저장
        order.getProductList().add(product1);
        order.getProductList().add(product2);
        em.persist(order);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate: 
    
    create table S_ITEM (
       ORD_ID bigint not null,
        PRODUCT_ID bigint not null
    )
Hibernate: 
    
    create table S_ORD (
       id bigint generated by default as identity,
        CUSTOMER_ID bigint,
        ORDER_DATE timestamp,
        total double,
        primary key (id)
    )
Hibernate: 
    
    create table S_PRODUCT (
       id bigint generated by default as identity,
        category varchar(255),
        name varchar(255),
        SHORT_DESC varchar(255),
        primary key (id)
    )
Hibernate: 
    
    alter table S_ITEM 
       add constraint UK1min9dm3xj2einmn4tq8gscwk unique (ORD_ID, PRODUCT_ID)
Hibernate: 
    
    alter table S_ITEM 
       add constraint FKi0210b7rxwtlk1tquh6eqj8sy 
       foreign key (PRODUCT_ID) 
       references S_PRODUCT
Hibernate: 
    
    alter table S_ITEM 
       add constraint FKhn9efciwou1aoordkugwpqtye 
       foreign key (ORD_ID) 
       references S_ORD
```

<p>주문 엔티티아ㅗ 매핑될 <code>S_ORD</code> 테이블과 상품 엔티티와 매핑되로 <code>S_PRODUCT</code>테이블, 그리고 두 테이블을 연결해줄 <code>S_ITEM</code>테이블이 생성되었습니다. 그리고 <code>S_ITEM</code>테이블에는 두 테이블을 참조할 <code>외래 키(PRODUCT_ID, ORD_ID)</code>가 각각 설정 되었습니다.</p>

<p>외래 키로 사용할 <code>PRODUCT_ID</code>와 <code>ORD_ID</code>는 동시에 복합키로도 사용되었습니다. 이것이 앞에서 설명한 <code>식별관계(Identifying Relationship)</code>입니다.</p>

<p>테이블 생성 밑에는 데이터 등록 관련 <code>SQL</code>들이 출력되고 그 밑에 검색 결과도 출력됩니다.</p>

```
Hibernate: 
    select
        order0_.id as id1_3_0_,
        order0_.CUSTOMER_ID as customer2_3_0_,
        order0_.ORDER_DATE as order_da3_3_0_,
        order0_.total as total4_3_0_ 
    from
        S_ORD order0_ 
    where
        order0_.id=?
1번 주문에 대한 상품 목록
Hibernate: 
    select
        productlis0_.ORD_ID as ord_id1_2_0_,
        productlis0_.PRODUCT_ID as product_2_2_0_,
        product1_.id as id1_4_1_,
        product1_.category as category2_4_1_,
        product1_.name as name3_4_1_,
        product1_.SHORT_DESC as short_de4_4_1_ 
    from
        S_ITEM productlis0_ 
    inner join
        S_PRODUCT product1_ 
            on productlis0_.PRODUCT_ID=product1_.id 
    where
        productlis0_.ORD_ID=?
---> LG 통돌이 세탁기
---> 다이슨 청소기
```

<p><cocde>@ManyToMany</cocde> 어노테이션의 기본 <code>fetch</code>설정이 <code>FetchType.LAZY</code>로 되어 있기 때문에 주문 정보만 사용할 때는 조인 쿼리를 사용하지 않고 <code>S_ORD</code>테이블만 조회합니다. 하지만 상품 목록을 출력하려고 할 때, <code>S_ITEM</code>와 <code>S_PRODUCT</code>테이블이 조인되는 것을 확인할 수 있습니다.</p>

```
import lombok.Data;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

@Data
@Entity
@Table(name = "S_ORD")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;            // 주문 아이디

    @Column(name = "CUSTOMER_ID")
    private Long customerId;    // 고객 아이디

    @Column(name = "ORDER_DATE")
    private Date orderDate;     // 주문 날짜

    private Double total;       // 주문 금액

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "S_ITEM"
            , joinColumns = @JoinColumn(name = "ORD_ID")
            , inverseJoinColumns = @JoinColumn(name = "PRODUCT_ID")
            , uniqueConstraints = @UniqueConstraint(columnNames = {"ORD_ID", "PRODUCT_ID"})
    )
    private List<Product> productList = new ArrayList<>();
}
```

<p><code>@ManyToMany</code> 어노테이션의 <code>fetch</code>설정을 <code>FetchType.EAGER</code>로 변경하면 모든 데이터를 조인으로 한 번에 가져옵니다.</p>

```
Hibernate: 
    select
        order0_.id as id1_3_0_,
        order0_.CUSTOMER_ID as customer2_3_0_,
        order0_.ORDER_DATE as order_da3_3_0_,
        order0_.total as total4_3_0_,
        productlis1_.ORD_ID as ord_id1_2_1_,
        product2_.id as product_2_2_1_,
        product2_.id as id1_4_2_,
        product2_.category as category2_4_2_,
        product2_.name as name3_4_2_,
        product2_.SHORT_DESC as short_de4_4_2_ 
    from
        S_ORD order0_ 
    left outer join
        S_ITEM productlis1_ 
            on order0_.id=productlis1_.ORD_ID 
    left outer join
        S_PRODUCT product2_ 
            on productlis1_.PRODUCT_ID=product2_.id 
    where
        order0_.id=?
1번 주문에 대한 상품 목록
---> LG 통돌이 세탁기
---> 다이슨 청소기
```

<img width="366" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/eef438c9-f46a-42c6-8129-238106b39da3">

<h4>양방향 매핑하기</h4>

```
import lombok.Data;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Data
@Entity
@Table(name = "S_PRODUCT")
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;        // 상품 아이디

    private String name;    // 상품 이름

    @Column(name = "SHORT_DESC")
    private String shortDesc;   // 상품 설명

    private String category;    // 카테고리

    @ManyToMany(mappedBy = "productList")
    private List<Order> orderList = new ArrayList<>();
}
```

```
import lombok.Data;
import lombok.ToString;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

@Data
@ToString(exclude = "productList")
@Entity
@Table(name = "S_ORD")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;            // 주문 아이디

    @Column(name = "CUSTOMER_ID")
    private Long customerId;    // 고객 아이디

    @Column(name = "ORDER_DATE")
    private Date orderDate;     // 주문 날짜

    private Double total;       // 주문 금액

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "S_ITEM"
            , joinColumns = @JoinColumn(name = "ORD_ID")
            , inverseJoinColumns = @JoinColumn(name = "PRODUCT_ID")
            , uniqueConstraints = @UniqueConstraint(columnNames = {"ORD_ID", "PRODUCT_ID"})
    )
    private List<Product> productList = new ArrayList<>();

    // 상품(Product)를 등록할 때, 상품 쪽에 주문(Order) 정보도 설정한다.
    public void addProduct(Product product) {
        productList.add(product);

        // 반대쪽(Product)에도 주문에 대한 참조 정보를 설정한다.
        product.getOrderList().add(this);
    }
}
```

```
import org.example.chapter05.domain.Order;
import org.example.chapter05.domain.Product;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.util.Date;
import java.util.List;

public class ManyToManyBothWayNoRelationEntityClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter05");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();

        // 검색한 Order를 통해 Product 목록을 출력한다.
        Order order = em.find(Order.class, 1L);
        System.out.println(order.getId() + "번 주문에 대한 상품 목록");

        List<Product> productList = order.getProductList();
        for (Product product : productList) {
            System.out.println("---> " + product.getName());
        }

        // 검색한 Product를 통해 Order 목록을 출력한다.
        Product product = em.find(Product.class, 1L);

        System.out.println(product.getName() + " 상품에 대한 주문 정보");
        List<Order> orderList = product.getOrderList();
        for (Order ord : orderList) {
            System.out.println("---> " + ord.toString());
        }
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 1번 상품 목록
        Product product1 = new Product();
        product1.setName("LG 통돌이 세탁기");
        em.persist(product1);

        // 2번 상품 등록
        Product product2 = new Product();
        product2.setName("다이슨 청소기");
        em.persist(product2);

        // 1번 주문 등록
        Order order1 = new Order();
        order1.setOrderDate(new Date());
        order1.addProduct(product1);
        em.persist(order1);

        // 2번 주문 등록
        Order order2 = new Order();
        order2.setOrderDate(new Date());
        order2.addProduct(product1);
        em.persist(order2);

        em.getTransaction().commit();
        em.close();
    }
}
```

<p>순환 참조 문제를 해결하기 위해 <code>@ToString(exclude = "productList")</code>를 추가합니다. 상품 쪽 <code>주문목록(orderList)</code>에도 해당 주문에 대한 참조가 추가되도록 <code>addProduct</code>메소드를 작성합니다.</p>

```
(...)

1번 주문에 대한 상품 목록
---> LG 통돌이 세탁기
LG 통돌이 세탁기 상품에 대한 주문 정보

(...)

---> Order(id=1, customerId=null, orderDate=2024-07-06 19:47:05.413, total=null)
---> Order(id=2, customerId=null, orderDate=2024-07-06 19:47:05.425, total=null)
```

<h3>6. 연결 클래스를 사용하는 다대다 매핑</h3>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_ITEM")
public class Item {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "ORD_ID")
    private Order order;        // 주문 참조

    @ManyToOne
    @JoinColumn(name = "PRODUCT_ID")
    private Product product;    // 상품 참조

    private Long price;         // 주문 가격

    private Long quantity;      // 주문 수량

    // 주문(Order)과의 양방향 참조 설정
    public void setOrder(Order order) {
        this.order = order;

        order.getItemList().add(this);
    }


}
```

<p>연결 테이블에서 중요한 포인트 중 하나는 기본 키에 대한 관리입니다. 연결 테이블의 기본 키 전략은 앞에서 살펴본 대로 식별관계와 비식별관계 두 가지가 있습니다. 위 소스에서는 두 테이블의 기본 키를 연결 테이블에서는 단순히 외래 키로만 사용하도록 했고, 연결 테이블을 위한 별도의 기본 키를 추가해서 비식별 관계록 매핑했습니다.</p>

<p>그리고 위 설정대로라면 <code>Item</code>클래스와 매핑되는 <code>S_ITEM</code> 테이블에는 <code>ITEM_ID</code>라는 칼럼이 추가될 것이고 <code>Item.id</code> 변수에 설정된 <code>@GeneratedValue</code>에 의해서 자동으로 식별자 값이 증가할 것입니다.</p>

```
import lombok.Data;
import lombok.ToString;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

@Data
@ToString(exclude = "itemList")
@Entity
@Table(name = "S_ORD")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;            // 주문 아이디

    @Column(name = "CUSTOMER_ID")
    private Long customerId;    // 고객 아이디

    @Column(name = "ORDER_DATE")
    private Date orderDate;     // 주문 날짜

    private Double total;       // 주문 금액

    @OneToMany(mappedBy = "order")
    private List<Item> itemList = new ArrayList<>();
}
```

<p>주문 정보를 조회하면 해당 주문과 관련된 <code>주문내역(Item)</code>목록을 얻을 수 있도록 <code>itemList</code>라는 컬렉션 변수를 추가 했습니다. 그리고 다대일 관계를 양방향으로 매핑했을 때, 연관관계 소유자는 외래 키를 가진 <code>다(Many)</code>쪽에 있으므로 <code>일</code>에 해당하는 주문 객체에 <code>mappedBy</code>속성을 설정했습니다.</p>

```
import lombok.Data;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Data
@Entity
@Table(name = "S_PRODUCT")
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;        // 상품 아이디

    private String name;    // 상품 이름

    @Column(name = "SHORT_DESC")
    private String shortDesc;   // 상품 설명

    private String category;    // 카테고리
}
```

```
import org.example.chapter05.domain.Item;
import org.example.chapter05.domain.Order;
import org.example.chapter05.domain.Product;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.util.Date;
import java.util.List;

public class ManyToManyBothWayNoRelationEntityClient {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter05");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();

        // 검색한 Order를 통해 Product 목록을 출력한다.
        Order order = em.find(Order.class, 1L);
        System.out.println("주문 날짜 : " + order.getOrderDate());
        System.out.println("[주문 목록]");

        List<Item> itemList = order.getItemList();
        for (Item item : itemList) {
            System.out.println("---> " + item.getProduct().getName());
        }
    }

    private static void dataInsert(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 상품 등록
        Product product1 = new Product();
        product1.setName("LG 통돌이 세탁기");
        em.persist(product1);

        Product product2 = new Product();
        product2.setName("갤럭시 20");
        em.persist(product2);

        // 주문 등록
        Order order = new Order();
        order.setOrderDate(new Date());
        em.persist(order);

        // 카트 등록
        Item item1 = new Item();
        item1.setOrder(order);
        item1.setProduct(product1);
        item1.setPrice(100_000L);
        em.persist(item1);

        Item item2 = new Item();
        item2.setOrder(order);
        item2.setProduct(product2);
        item2.setPrice(270_000L);
        item2.setQuantity(3L);
        em.persist(item2);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate: 
    
    create table S_ITEM (
       id bigint generated by default as identity,
        price bigint,
        quantity bigint,
        ORD_ID bigint,
        PRODUCT_ID bigint,
        primary key (id)
    )

Hibernate: 
    
    alter table S_ITEM 
       add constraint FKhn9efciwou1aoordkugwpqtye 
       foreign key (ORD_ID) 
       references S_ORD
Hibernate: 
    
    alter table S_ITEM 
       add constraint FKi0210b7rxwtlk1tquh6eqj8sy 
       foreign key (PRODUCT_ID) 
       references S_PRODUCT
```

<p><code>연결 테이블(S_ITEM)</code>에 <code>ITEM_ID</code>라는 새로운 기본 키 칼럼이 추가됐습니다. 그리고 <code>ORD_ID</code>와 <code>PRODUCT_ID</code>는 각각 다른 테이블을 참조하는 외래 키로만 사용되고 있습니다.</p>
