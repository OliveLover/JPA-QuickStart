<h1>5. 다양한 연관관계 매핑</h1>

<h3>1. 일대일 단방향 매핑</h3>

<p> 다중성 측면에서 일대일 관계는 관계에 참여하는 테이블이나 엔티티가 상대방에 대해서 하나의 관계만 가집니다. 방향성 측면에서 단방향은 하나의 엔티티에서만 다른 엔티티의 참조를 유지하도록 하는 것입니다.</p>

<h4>가정</h4>

```
사원증(EmployeeCard)과 직원(Employee)이 있습니다.
하나의 사원증은 한 명의 직원에 의해서만 소유될 수 있습니다.
사원증과 직원은 일대일 관계입니다.
사원증을 조회했을 때, 사원증을 소유한 직원 정보도 같이 사용할 수 있습니다.
반대로 사원을 통해서는 사원증 정보에 접근할 수는 없습니다.
```

<h4>ERD</h4>
<img width="595" alt="스크린샷 2024-07-06 오전 11 36 22" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/1be92bcf-2ac4-4fc3-92ba-33dc2cc84700">

<h4>Class Diagram</h4>

<p>객체 지향 관점에서 보면 직원을 통해 직원이 소유한 사원증을 사용할 수 있도록 하는 것이 더 적합할 수 있습니다. 아래는 객체지향적인 관점에서 작성한 클래스 다이어그램입니다.</p>

<img width="413" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/4852c637-4220-416a-b665-f52ed9a12708">

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;
}
```

```
import lombok.Data;

import javax.persistence.*;
import java.util.Date;

@Data
@Entity
@Table(name = "S_EMP_CARD")
public class EmployeeCard {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column
    private Long cardId;    // 사원증 아이디

    @Column(name = "EXPIRE_DATE")
    private Date expireDate;    // 사원증 만료 기간

    private String role;   // 권한

    @OneToOne
    @JoinColumn(name = "EMP_CARD_ID")
    private Employee employee;
}
```

```
import org.example.chapter05.domain.Employee;
import org.example.chapter05.domain.EmployeeCard;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.text.ParseException;
import java.text.SimpleDateFormat;

public class OneToOneOneWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf =
                Persistence.createEntityManagerFactory("Chapter05");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();

        EmployeeCard employeeCard = em.find(EmployeeCard.class, 1L);
        System.out.println("검색된 사원증 번혼 : " + employeeCard.getCardId());
        System.out.println("권한 : " + employeeCard.getRole());
        System.out.println("사원증 소유자 : " + employeeCard.getEmployee().getName());
    }

    private static void dataInsert(EntityManagerFactory emf) throws ParseException {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 직원 등록
        Employee employee = new Employee();
        employee.setName("둘리");
        em.persist(employee);

        // 사원증 등록
        EmployeeCard card = new EmployeeCard();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        card.setExpireDate(dateFormat.parse("2025-12-31"));
        card.setRole("MASTER");
        // 직원에 대한 참조 설정
        card.setEmployee(employee);

        em.persist(card);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate: 
    
    create table S_EMP_CARD (
       cardId bigint generated by default as identity,
        EXPIRE_DATE timestamp,
        role varchar(255),
        EMP_CARD_ID bigint,
        primary key (cardId)
    )
Hibernate: 
    
    alter table S_EMP_CARD 
       add constraint FKktkkxy8rry12gqixjk25ws9k3 
       foreign key (EMP_CARD_ID) 
       references S_EMP

Hibernate: 
    insert 
    into
        S_EMP
        (id, name) 
    values
        (default, ?)
Hibernate: 
    insert 
    into
        S_EMP_CARD
        (cardId, EMP_CARD_ID, EXPIRE_DATE, role) 
    values
        (default, ?, ?, ?)
Hibernate: 
    select
        employeeca0_.cardId as cardid1_1_0_,
        employeeca0_.EMP_CARD_ID as emp_card4_1_0_,
        employeeca0_.EXPIRE_DATE as expire_d2_1_0_,
        employeeca0_.role as role3_1_0_,
        employee1_.id as id1_0_1_,
        employee1_.name as name2_0_1_ 
    from
        S_EMP_CARD employeeca0_ 
    left outer join
        S_EMP employee1_ 
            on employeeca0_.EMP_CARD_ID=employee1_.id 
    where
        employeeca0_.cardId=?
검색된 사원증 번혼 : 1
권한 : MASTER
사원증 소유자 : 둘리
```

<p> 클라이언트를 실행했을 때 <code>사원증(S_EMP_CARD)</code>테이블에 <code>EMP_CARD_ID</code>라는 외래 키 칼럼이 포함되고 그에 해당하는 제약조건도 적절히 설정되는 것을 확인할 수 있습니다.</p>

<p>실행된 검색 쿼리는 <code>사원증(S_EMP_CARD)</code>과 <code>사원(S_EMP)</code> 테이블을 <code>외부 조인</code>으로 연결하고 있습니다. </p>

<img width="365" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/ded5abf0-47a6-4ea8-9750-242d9735777b">

<h4>외부 조인을 내부 조인으로 변경하기</h4>

<p>외부 조인은 내부 조인보다 성능이 떨어집니다. 일대일 단방향 매핑 설정은 기본적으로 외부 조인으로 처리됩니다. <code>@OneToOne</code>어노테이션에 <code>optional</code>속성을 추가합니다.</p>

```
import lombok.Data;

import javax.persistence.*;
import java.util.Date;

@Data
@Entity
@Table(name = "S_EMP_CARD")
public class EmployeeCard {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column
    private Long cardId;    // 사원증 아이디

    @Column(name = "EXPIRE_DATE")
    private Date expireDate;    // 사원증 만료 기간

    private String role;   // 권한

    @OneToOne(optional = false)
    @JoinColumn(name = "EMP_CARD_ID")
    private Employee employee;
}
```

```
Hibernate: 
    select
        employeeca0_.cardId as cardid1_1_0_,
        employeeca0_.EMP_CARD_ID as emp_card4_1_0_,
        employeeca0_.EXPIRE_DATE as expire_d2_1_0_,
        employeeca0_.role as role3_1_0_,
        employee1_.id as id1_0_1_,
        employee1_.name as name2_0_1_ 
    from
        S_EMP_CARD employeeca0_ 
    inner join
        S_EMP employee1_ 
            on employeeca0_.EMP_CARD_ID=employee1_.id 
    where
        employeeca0_.cardId=?
검색된 사원증 번혼 : 1
권한 : MASTER
사원증 소유자 : 둘리
```

<h4>페치 전략 변경하기</h4>

<p><code>@OneToOne</code>은 <code>@ManyToOne</code>과 마찬가지로 연관관계에 있는 객체가 하나이므로 <code>fetch</code> 속성에 대한 기본 설정이 <code>FetchType.EAGER</code>로 되어 있습니다. 따라서 사원증을 조회했을 때 무조건 쿼리가 실행되어 연관된 직원 객체도 같이 조회 되었습니다.</p>

```
import lombok.Data;

import javax.persistence.*;
import java.util.Date;

@Data
@Entity
@Table(name = "S_EMP_CARD")
public class EmployeeCard {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "CARD_ID")
    private Long cardId;    // 사원증 아이디

    @Column(name = "EXPIRE_DATE")
    private Date expireDate;    // 사원증 만료 기간

    private String role;   // 권한

    @OneToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "EMP_CARD_ID")
    private Employee employee;
}
```

```
Hibernate: 
    select
        employeeca0_.CARD_ID as card_id1_1_0_,
        employeeca0_.EMP_CARD_ID as emp_card4_1_0_,
        employeeca0_.EXPIRE_DATE as expire_d2_1_0_,
        employeeca0_.role as role3_1_0_ 
    from
        S_EMP_CARD employeeca0_ 
    where
        employeeca0_.CARD_ID=?
검색된 사원증 번혼 : 1
권한 : MASTER
Hibernate: 
    select
        employee0_.id as id1_0_0_,
        employee0_.name as name2_0_0_ 
    from
        S_EMP employee0_ 
    where
        employee0_.id=?
사원증 소유자 : 둘리
```

<p>실행 결과를 보면 클라이언트가 사원증에 대한 정보만 사용하는 경우에은 <code>S_EMP_CARD</code>테이블만 조회합니다. 그러다 직원 이름을 출력하는 순간 <code>S_EMP</code>테이블을 조회하는 것을 확인할 수 있습니다.</p>

<h3>2. 일대일 양방향 매핑</h3>

<p>다대일 관계에서는 자식 테이블에 해당하는 <code>다(Many)</code>쪽에서 외래 키를 가지도록 했습니다. 그래서 다대일 관계를 양방향으로 변환할 때, 자연스럽게 <code>다(Many)</code>에 해당하는 엔티티를 연관관계의 소유자로 설정할 수 있었습니다. 하지만 일대일 관계에서는 어느 쪽에서든 외래 키를 가질 수 있기 때문에 두 테이블 중에 어떤 테이블에서 외래키를 가지게 할지 결정해야 합니다. 외래 키의 위치가 중요한 이유는 외래 키를 기준으로 양방향 연관관계 매핑에서 소유자를 결정할 수 있기 때문입니다.</p>

<p>일대일 단반향을 양방향으로 매핑으로 변경하기 위해서 다음과 같은 조건을 가정합니다.</p>

```
사원증(Employee)과 직원(Employee)이 있습니다.
하나의 사원증은 한 명의 직원에 의해서만 소유될 수 있습니다.
사원증과 직원은 일대일 관계입니다.
사원증을 조회했을 때, 사원증을 소유한 직원 정보도 사용할 수 있습니다.
반대로 직원 정보를 조회했을 때, 직원이 소유한 사원증 정보도 같이 사용하라 수있습니다.
```

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @OneToOne(mappedBy = "employee")
    private EmployeeCard card;
}
```

<p>양방향 매핑에서는 매핑에 참여하는 두 엔티티 중 하나를 반드시 소유자로 지정해야 합니다. 다대일 양방향 매핑에서 확인했듯이 <code>일반적으로 외래키를 소유한 엔티티가 연관관계의 소유자</code>가 됩니다. 따라서 현재 <code>S_EMP_CARD</code>테이블에 외래 키가 설정되어 있기 때문에 <code>EmployeeCard</code>가 연관관계의 소유자가 됩니다. 따라서 소유자가 아닌 <code>Employee</code>에는 <code>mappedBy</code>속성을 추가하여 자신이 소유자가 아님을 <code>영속 컨테이너</code>에게 알려줘야 합니다.</p>

```
import org.example.chapter05.domain.Employee;
import org.example.chapter05.domain.EmployeeCard;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.text.ParseException;
import java.text.SimpleDateFormat;

public class OneToOneBothWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf =
                Persistence.createEntityManagerFactory("Chapter05");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();

        // 검색된 사원증을 통해 직원 정보 사용하기
        EmployeeCard employeeCard = em.find(EmployeeCard.class, 1L);
        System.out.println("사원증 유효기간 : " + employeeCard.getExpireDate());
        System.out.println("사원증 소유자 : " + employeeCard.getEmployee().getName());

        // 검색된 직원을 통해 사원증 정보 사용하기
        Employee employee = em.find(Employee.class, 1L);
        System.out.println("사원증 소유자 : " + employee.getName());
        System.out.println("사원증 유효기간 : " + employee.getCard().getExpireDate());
    }

    private static void dataInsert(EntityManagerFactory emf) throws ParseException {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 직원 등록
        Employee employee = new Employee();
        employee.setName("둘리");
        em.persist(employee);

        // 사원증 등록
        EmployeeCard card = new EmployeeCard();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        card.setExpireDate(dateFormat.parse("2025-12-31"));
        card.setRole("MASTER");
        // 직원에 대한 참조 설정
        card.setEmployee(employee);

        em.persist(card);

        em.getTransaction().commit();
        em.close();
    }
}
```

<p>작성된 클라이언트 소스에서 <code>dataSelect</code> 메소드를 보면 먼저 <code>사원증(EmployeeCard)</code>객체를 검색하고, <code>참조 변수(EmployeeCard.employee)</code>를 통해 직원 정보를 사용하고 있습니다. 그리고 그 아래에는 반대로 <code>직원(Employee)</code> 객체를 검색한 후에 <code>참조 변수(Employee.card)</code>를 통해 사원증 객체를 사용하고 있습니다. 이렇게 양방향 매핑으로 설정된 객체들은 어떤 객체를 검색하더라도 반대쪽 객체를 같이 사용할 수 있습니다.</p>

<h4>순수한 객체로서의 양방향 참조</h4>

<p><code>OneToOneBothWayClient</code>의 <code>dataInsert</code> 메소드를 보면 사워 객체를 생성한 후에 직원 객체를 할당했습니다. 따라서 사원증을 통해 직원 정보를 접근했을 때는 문제가 되지 않습니다. 그런데 <code>직원 객체의 참조 변수(Employee.card)</code>에는 사원증 객체가 할당되지 않았기 때문에 직원 객체를 통해 사원증 객체를 사용하려고 하면, 예외가 발생합니다.</p>


```
public class OneToOneBothWayClient {
(...)

    private static void dataInsert(EntityManagerFactory emf) throws ParseException {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 직원 등록
        Employee employee = new Employee();
        employee.setName("둘리");
        em.persist(employee);

        // 사원증 등록
        EmployeeCard card = new EmployeeCard();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        card.setExpireDate(dateFormat.parse("2025-12-31"));
        card.setRole("MASTER");
        // 직원에 대한 참조 설정
        card.setEmployee(employee);

        em.persist(card);

        em.getTransaction().commit();
        em.close();

        System.out.println("사원증을 통한 직원 정보 접근 : " + card.getEmployee().getName());
        System.out.println("직원을 통한 사원증 정보 접근 : " + employee.getCard().getExpireDate());
    }
}
```

<p>수정된 클라이언트를 실행하면 사원증 객체를 통한 직원 정보 접근은 가능하지만 반대인 직원 객체를 통한 사원증 정보 사용은 불가능하기 때문에 <code>NullPointerException</code>이 발생합니다. 따라서 <code>EmployeeCard</code>클래스에 양방향 참조 메소드를 추가하여 사원증에 직원에 대한 참조를 설정할 때, 자동으로 상호 간 참조가 이루어지도록 해야합니다.</p>

```
import lombok.Data;

import javax.persistence.*;
import java.util.Date;

@Data
@Entity
@Table(name = "S_EMP_CARD")
public class EmployeeCard {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "CARD_ID")
    private Long cardId;    // 사원증 아이디

    @Column(name = "EXPIRE_DATE")
    private Date expireDate;    // 사원증 만료 기간

    private String role;   // 권한

    @OneToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "EMP_CARD_ID")
    private Employee employee;

    public void setEmployee(Employee employee) {
        this.employee = employee;
        employee.setCard(this);
    }
}
```

```
사원증 소유자 : 둘리
사원증 유효기간 : 2025-12-31 00:00:00.0
```

<h4>순환참조 문제 해결</h4>

<p>양방향 참조에서는 순수한 객체 상태에서의 양방향 참조도 신경 써야 하지만 순화 참조 문제도 고려해야 합니다. 현재 작성한 클라이언트(OneToOneBothWayClinet)에서는 각자가 참조하는 상대 객체의 특정 변수만 사용하기 때문에 문제가 없습니다.</p>

```
System.out.println("사원증을 통한 직원 정보 접근 : " + card.getEmployee().getName());
System.out.println("직원을 통한 사원증 정보 접근 : " + employee.getCard().getExpireDate());
```

<p>하지만 만약 모든 변수 값을 확인하기 위해서 <code>toString</code>메소드를 호출하면 순환참조 문제가 발생됩니다.</p>

```
public class OneToOneBothWayClient {

    (...)

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();

        // 검색된 사원증을 통해 직원 정보 사용하기
        EmployeeCard employeeCard = em.find(EmployeeCard.class, 1L);
        System.out.println("사원증을 통한 직원 정보 접근 : " + employeeCard.toString());

    (...)
}
```

<img width="954" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/297181c5-4616-4008-bd2b-33b59c08ee48">

<p>수정된 클라이언트를 실행하면 순환참조에 의해서 다음과 같이 <code>java.lang.StackOverflowError</code>가 발생하는 것을 확인할 수 있습니다.</p>

<p>이런 순환참조 문제를 해결하기 위해서는 롬복이 생성하는 <code>toString</code> 메소드에서 순환참조에 사용되는 참조 변수를 제외시켜야 합니다. 이는 마치 <code>EqualsAndHashCode</code>어노테이션에서 순환 참조 문제를 해결하기 위해 <code>exclude</code>속성을 이용했던 것과 같은 개념으로 이해할 수 있습니다.</p>

```
import lombok.Data;
import lombok.ToString;

import javax.persistence.*;
import java.util.Date;

@Data
@ToString(exclude = "employee")
@Entity
@Table(name = "S_EMP_CARD")
public class EmployeeCard {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "CARD_ID")
    private Long cardId;    // 사원증 아이디

    @Column(name = "EXPIRE_DATE")
    private Date expireDate;    // 사원증 만료 기간

    private String role;   // 권한

    @OneToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "EMP_CARD_ID")
    private Employee employee;

    public void setEmployee(Employee employee) {
        this.employee = employee;
        employee.setCard(this);
    }
}
```

<p>이제 <code>EmployeeCard</code> 클래스 위에 선언된 <code>@ToString</code>은 롬복에게 <code>toString</code>메소드를 재정의할 때, <code>employee</code> 변수는 <code>toString</code>메소드에 포함시키지 않습니다.</p>

<h4>반대 방향으로의 연관관계 매핑</h4>

<p>일대일 연관관계에는 반대도 당연히 일대일 관계이므로 지금까지의 설정과 반대로 부모 테이블 쪽에 외래 키를 두는 것도 가능합니다. 그리고 이 상황이 자바 프로그래밍을 오래 해본 개발자들에게는 오히려 자연스러운 설정일 수 있습니다.</p>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @OneToOne(optional = false , fetch = FetchType.LAZY)
    @JoinColumn(name = "EMP_CARD_ID")
    private EmployeeCard card;

    public void setEmployeeCard(EmployeeCard card) {
        this.card = card;
        card.setEmployee(this);
    }
}
```

<p>이전과 반대로 <code>Employee</code>클래스에 <code>EmployeeCard</code> 객체를 참조할 <code>card</code>변수를 추가했습니다. 그리고 <code>@OneToOne</code>어노테이션을 설정했으며, <code>@JoinColumn</code>을 이용하여 <code>S_EMP</code> 테이블에 추가할 외래 키 칼럼 이름도 지정했습니다. 그리고 아래쪽에는 두 객체들이 상호 간에 참조 정보를 유지할 수 있도록 양방향 참조 메소드(setEmployeeCard)도 추가했습니다.</p>

```
import lombok.Data;
import lombok.ToString;

import javax.persistence.*;
import java.util.Date;

@Data
@ToString(exclude = "employee")
@Entity
@Table(name = "S_EMP_CARD")
public class EmployeeCard {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "CARD_ID")
    private Long cardId;    // 사원증 아이디

    @Column(name = "EXPIRE_DATE")
    private Date expireDate;    // 사원증 만료 기간

    private String role;   // 권한

    @OneToOne(mappedBy = "card")
    private Employee employee;
}
```

<p><code>EmployeeCard</code>는 연관관계에서 소유자가 아니기 때문에 <code>@OneToOne</code>어노테이션에 <code>mappedBy</code>속성을 추가하여 본인은 연관관계의 주인이 아님을 선언했고, <code>mappedBy</code>속성 값으로 <code>연관관계 주인(Employee)</code>쪽의 <code>참조 변수(card)</code>를 지정했습니다.</p>

```
import org.example.chapter05.domain.Employee;
import org.example.chapter05.domain.EmployeeCard;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.text.ParseException;
import java.text.SimpleDateFormat;

public class OneToOneBothWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf =
                Persistence.createEntityManagerFactory("Chapter05");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();


        Employee employee = em.find(Employee.class, 1L);
        System.out.println("사원증을 통한 직원 정보 접근 : " + employee.getCard().toString());
    }

    private static void dataInsert(EntityManagerFactory emf) throws ParseException {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 사원증 등록
        EmployeeCard card = new EmployeeCard();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        card.setExpireDate(dateFormat.parse("2025-12-31"));
        card.setRole("MASTER");
        em.persist(card);

        // 직원 등록
        Employee employee = new Employee();
        employee.setName("둘리");
        // 사원증에 대한 참조 설정
        employee.setEmployeeCard(card);
        em.persist(employee);


        em.getTransaction().commit();
        em.close();
    }
}
```

|S_EMP_CARD 테이블에 외래 키(이전 상황)|S_EMP 테이블에 외래 키 (지금 상황)|
|---|---|
|<img width="375" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/d9846598-0509-467d-adfd-58b81333510c">|<img width="295" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/dc687089-993a-4b50-a729-f018cbe9a2c4">|

<h3>3. 부모 키를 공유하는 일대일 매핑</h3>

<p>지금까지는 부모 테이블의 기본 키를 자식 테이블에서 외래 키로만 사용하는 일대일 관계를 살펴봤습니다. 그런데 일대일 관계를 매핑하다보면 부모 테이블의 기본키를 자식 테이블에서 외래 키와 동시에 자식 테이블의 기본 키로도 사용하는 경우가 있습니다.</p>

<p>예를 들어 직원 테이블의 기본 키는 <code>직원 아이디(ID)</code>칼럼이고, 사원증 테이블의 기본 키는 <code>사원증 아이디(EMP_ID)</code>칼럼입니다. 부모 키를 공유하는 일대일 관계는 직원의 아이디와 사원증 아이디가 동일한 상태를 의미합니다. 이 경우, 사원증 테이블은 다음 그림과 같이 <code>직원(S_EMP)</code> 테이블과 동일한 값을 가지는 <code>칼럼(EMP_ID)</code> 기본 키로 사용하는 동시에 외래 키로도 사용합니다.</p>

<h4>ERD</h4>

<img width="557" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/b90a8a6d-d9a9-4d6f-8a2d-37207fb62be0">

<h4>Class Diagram</h4>

<img width="429" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/baa7bd17-7433-4cc6-afbe-7ba080a3473d">

<p><code>S_EMP_CARD</code>테이블과 맾ㅇ된 <code>EmployeeCard</code>엔티티는 <code>Employee</code>타입의 변수를 멤버 변수로 가지며, <code>Employee</code>객체를 참조하는 일대일 관계를 맺게 됩니다. 이렇게 부모 키를 공유하며 자식의 기본 키와 동시에 외래 키로 사용하는 일대일 관계를 매핑하기 위해서는 <code>@MapsId</code>라는 특별한 어노테이션을 사용해야 합니다.</p>

```
import lombok.Data;
import lombok.ToString;

import javax.persistence.*;
import java.util.Date;

@Data
@ToString(exclude = "employee")
@Entity
@Table(name = "S_EMP_CARD")
public class EmployeeCard {

    @Id
    @Column(name = "CARD_ID")
    private Long cardId;    // 사원증 아이디

    @Column(name = "EXPIRE_DATE")
    private Date expireDate;    // 사원증 만료 기간

    private String role;   // 권한

    @MapsId
    @OneToOne
    @JoinColumn(name = "EMP_ID")
    private Employee employee;
}
```

<p><code>EmployeeCard</code> 클래스에서 가장 먼저 주목할 부분은 <code>cardId</code>변수에 선언했던 <code>GeneratedValue</code>가 삭제된 것입니다. 이는 <code>@GeneratedValue</code>에 의해서 자동으로 증가된 식별자 값을 사용하지 않고, 부모 엔티티인 <code>Employee</code>객체의 식별자 값을 같이 사용하기 위함입니다.</p>

<p>그리고 <code>employee</code>변수에 일대일 매핑을 위해 <code>@OneToOne</code>, <code>@JoinColumn</code>, <code>@MapsId</code>를 설정했습니다. 먼저 <code>@JoinColumn(name = "EMP_ID")</code>은 <code>EmployeeCard</code>와 매핑된 <code>S_EMP_CARD</code>테이블에 <code>EMP_ID</code>칼럼을 추가하여 외래 키 칼럼으로 사용하라는 의미입니다. 그런데 <code>@JoinColumn</code>위에 <code>@MapsId</code>라는 새로운 어노테이션을 추가했는데, <code>@MapsId</code>는 <code>JoinColumn</code>으로 매핑한 외래 키 칼럼을 기본 키 칼럼으로도 사용하겠다는 의미의 설정입니다.</p>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

}
```

```
import org.example.chapter05.domain.Employee;
import org.example.chapter05.domain.EmployeeCard;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.text.ParseException;
import java.text.SimpleDateFormat;

public class OneToOneOneWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf =
                Persistence.createEntityManagerFactory("Chapter05");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();
        EmployeeCard employeeCard = em.find(EmployeeCard.class, 1L);
        System.out.println("검색된 사원증 번혼 : " + employeeCard.getCardId());
        System.out.println("권한 : " + employeeCard.getRole());
        System.out.println("사원증 소유자 : " + employeeCard.getEmployee().getName());
    }

    private static void dataInsert(EntityManagerFactory emf) throws ParseException {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 직원 등록
        Employee employee = new Employee();
        employee.setName("둘리");
        em.persist(employee);

        // 사원증 등록
        EmployeeCard card = new EmployeeCard();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        card.setExpireDate(dateFormat.parse("2025-12-31"));
        card.setRole("MASTER");
        card.setEmployee(employee);
        em.persist(card);

        em.getTransaction().commit();
        em.close();
    }
}
```

```
Hibernate: 
    
    create table S_EMP (
       id bigint generated by default as identity,
        name varchar(25) not null,
        primary key (id)
    )
Hibernate: 
    
    create table S_EMP_CARD (
       EMP_ID bigint not null,
        EXPIRE_DATE timestamp,
        role varchar(255),
        primary key (EMP_ID)
    )
Hibernate: 
    
    alter table S_EMP_CARD 
       add constraint FKgvqnf20bcuno9ssgeysu0uoc 
       foreign key (EMP_ID) 
       references S_EMP
```

<p>실행 결과를 보면 <code>S_EMP_CARD</code>테이블에 <code>EMP_ID</code>가 기본 키로 사용되면서 동시에 <code>S_EMP</code>테이블의 기본 키인 <code>ID</code>를 참조하는 외래 키로도 사용되고 있는 것을 확인할 수 있습니다.</p>

<img width="270" alt="image" src="https://github.com/OliveLover/JPA-QuickStart/assets/118647313/de59eeb3-4539-4e29-8ffd-520ffb7577e8">

<h4>양방향 매핑 설정</h4>

```
import lombok.Data;

import javax.persistence.*;

@Data
@Entity
@Table(name = "S_EMP")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 25, nullable = false)
    private String name;

    @OneToOne(mappedBy = "employee")
    private EmployeeCard card;

    public void setEmployeeCard(EmployeeCard card) {
        this.card = card;
        card.setEmployee(this);
    }
}
```

<p>수정된 <code>Employee</code>에는 사원증 객체를 참조하는 참조 변수가 추가 됐고, 변수 위에 <code>@OneToOne</code>을 설정했습니다. 그리고 <code>Employee</code>는 양방향 매핑에서 소유자가 아니므로 <code>@OneToOne</code>어노테이션에 <code>mappedBy</code>속성을 추가했습니다. 마지막으로 <code>setEmployeeCard</code>메소드를 통해 단순한 객체 상태에서도 양방향 참조가 가능하도록 했습니다.</p>

```
import org.example.chapter05.domain.Employee;
import org.example.chapter05.domain.EmployeeCard;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import java.text.ParseException;
import java.text.SimpleDateFormat;

public class OneToOneBothWayClient {
    public static void main(String[] args) {
        EntityManagerFactory emf =
                Persistence.createEntityManagerFactory("Chapter05");
        try {
            dataInsert(emf);
            dataSelect(emf);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            emf.close();
        }
    }

    private static void dataSelect(EntityManagerFactory emf) {
        EntityManager em = emf.createEntityManager();

        EmployeeCard employeeCard = em.find(EmployeeCard.class, 1L);
        System.out.println("검색된 사원증 번호 : " + employeeCard.getCardId());
        System.out.println("권한 : " + employeeCard.getRole());
        System.out.println("사원증 소유자 : " + employeeCard.getEmployee().getName());

        Employee employee = em.find(Employee.class, 1L);
        System.out.println("검색된 직원 이름 : " + employee.getName());
        System.out.println("직원이 소유한 사원증 권한 : " + employee.getCard().getRole());
    }

    private static void dataInsert(EntityManagerFactory emf) throws ParseException {
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();

        // 직원 등록
        Employee employee = new Employee();
        employee.setName("둘리");
        em.persist(employee);

        // 사원증 등록
        EmployeeCard card = new EmployeeCard();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        card.setExpireDate(dateFormat.parse("2025-12-31"));
        card.setRole("MASTER");
        // 직원에 대한 참조 설정
        card.setEmployee(employee);
        em.persist(card);

        em.getTransaction().commit();
        em.close();
    }
}
```

<p><code>dataInsert</code>메소드에서 객체 등록 순서를 변경했습니다. 즉, 사원증을 먼저 등록했던 코드를 직원을 먼저 등록하고 등록된 직원을 사원증 객체에 할당하도록 수정해야 합니다.</p>

